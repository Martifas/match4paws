{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/errors/index.js"],"sourcesContent":["export class SdkError extends Error {\n}\n/**\n * Errors that come from Auth0 in the `redirect_uri` callback may contain reflected user input via the OpenID Connect `error` and `error_description` query parameter.\n * You should **not** render the error `message`, or `error` and `error_description` properties without properly escaping them first.\n */\nexport class OAuth2Error extends SdkError {\n    constructor({ code, message }) {\n        super(message ??\n            \"An error occured while interacting with the authorization server.\");\n        this.name = \"OAuth2Error\";\n        this.code = code;\n    }\n}\nexport class DiscoveryError extends SdkError {\n    constructor(message) {\n        super(message ?? \"Discovery failed for the OpenID Connect configuration.\");\n        this.code = \"discovery_error\";\n        this.name = \"DiscoveryError\";\n    }\n}\nexport class MissingStateError extends SdkError {\n    constructor(message) {\n        super(message ?? \"The state parameter is missing.\");\n        this.code = \"missing_state\";\n        this.name = \"MissingStateError\";\n    }\n}\nexport class InvalidStateError extends SdkError {\n    constructor(message) {\n        super(message ?? \"The state parameter is invalid.\");\n        this.code = \"invalid_state\";\n        this.name = \"InvalidStateError\";\n    }\n}\nexport class AuthorizationError extends SdkError {\n    constructor({ cause, message }) {\n        super(message ?? \"An error occured during the authorization flow.\");\n        this.code = \"authorization_error\";\n        this.cause = cause;\n        this.name = \"AuthorizationError\";\n    }\n}\nexport class AuthorizationCodeGrantError extends SdkError {\n    constructor({ cause, message }) {\n        super(message ??\n            \"An error occured while trying to exchange the authorization code.\");\n        this.code = \"authorization_code_grant_error\";\n        this.cause = cause;\n        this.name = \"AuthorizationCodeGrantError\";\n    }\n}\nexport class BackchannelLogoutError extends SdkError {\n    constructor(message) {\n        super(message ??\n            \"An error occured while completing the backchannel logout request.\");\n        this.code = \"backchannel_logout_error\";\n        this.name = \"BackchannelLogoutError\";\n    }\n}\nexport var AccessTokenErrorCode;\n(function (AccessTokenErrorCode) {\n    AccessTokenErrorCode[\"MISSING_SESSION\"] = \"missing_session\";\n    AccessTokenErrorCode[\"MISSING_REFRESH_TOKEN\"] = \"missing_refresh_token\";\n    AccessTokenErrorCode[\"FAILED_TO_REFRESH_TOKEN\"] = \"failed_to_refresh_token\";\n})(AccessTokenErrorCode || (AccessTokenErrorCode = {}));\nexport class AccessTokenError extends SdkError {\n    constructor(code, message) {\n        super(message);\n        this.name = \"AccessTokenError\";\n        this.code = code;\n    }\n}\n/**\n * Enum representing error codes related to access tokens for connections.\n */\nexport var AccessTokenForConnectionErrorCode;\n(function (AccessTokenForConnectionErrorCode) {\n    /**\n     * The session is missing.\n     */\n    AccessTokenForConnectionErrorCode[\"MISSING_SESSION\"] = \"missing_session\";\n    /**\n     * The refresh token is missing.\n     */\n    AccessTokenForConnectionErrorCode[\"MISSING_REFRESH_TOKEN\"] = \"missing_refresh_token\";\n    /**\n     * Failed to exchange the refresh token.\n     */\n    AccessTokenForConnectionErrorCode[\"FAILED_TO_EXCHANGE\"] = \"failed_to_exchange_refresh_token\";\n})(AccessTokenForConnectionErrorCode || (AccessTokenForConnectionErrorCode = {}));\n/**\n * Error class representing an access token for connection error.\n * Extends the `SdkError` class.\n */\nexport class AccessTokenForConnectionError extends SdkError {\n    /**\n     * Constructs a new `AccessTokenForConnectionError` instance.\n     *\n     * @param code - The error code.\n     * @param message - The error message.\n     * @param cause - The OAuth2 cause of the error.\n     */\n    constructor(code, message, cause) {\n        super(message);\n        this.name = \"AccessTokenForConnectionError\";\n        this.code = code;\n        this.cause = cause;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAO,MAAM,iBAAiB;AAC9B;AAKO,MAAM,oBAAoB;IAC7B,YAAY,EAAE,IAAI,EAAE,OAAO,EAAE,CAAE;QAC3B,KAAK,CAAC,WACF;QACJ,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ;AACO,MAAM,uBAAuB;IAChC,YAAY,OAAO,CAAE;QACjB,KAAK,CAAC,WAAW;QACjB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ;AACO,MAAM,0BAA0B;IACnC,YAAY,OAAO,CAAE;QACjB,KAAK,CAAC,WAAW;QACjB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ;AACO,MAAM,0BAA0B;IACnC,YAAY,OAAO,CAAE;QACjB,KAAK,CAAC,WAAW;QACjB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ;AACO,MAAM,2BAA2B;IACpC,YAAY,EAAE,KAAK,EAAE,OAAO,EAAE,CAAE;QAC5B,KAAK,CAAC,WAAW;QACjB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ;AACO,MAAM,oCAAoC;IAC7C,YAAY,EAAE,KAAK,EAAE,OAAO,EAAE,CAAE;QAC5B,KAAK,CAAC,WACF;QACJ,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ;AACO,MAAM,+BAA+B;IACxC,YAAY,OAAO,CAAE;QACjB,KAAK,CAAC,WACF;QACJ,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ;AACO,IAAI;AACX,CAAC,SAAU,oBAAoB;IAC3B,oBAAoB,CAAC,kBAAkB,GAAG;IAC1C,oBAAoB,CAAC,wBAAwB,GAAG;IAChD,oBAAoB,CAAC,0BAA0B,GAAG;AACtD,CAAC,EAAE,wBAAwB,CAAC,uBAAuB,CAAC,CAAC;AAC9C,MAAM,yBAAyB;IAClC,YAAY,IAAI,EAAE,OAAO,CAAE;QACvB,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ;AAIO,IAAI;AACX,CAAC,SAAU,iCAAiC;IACxC;;KAEC,GACD,iCAAiC,CAAC,kBAAkB,GAAG;IACvD;;KAEC,GACD,iCAAiC,CAAC,wBAAwB,GAAG;IAC7D;;KAEC,GACD,iCAAiC,CAAC,qBAAqB,GAAG;AAC9D,CAAC,EAAE,qCAAqC,CAAC,oCAAoC,CAAC,CAAC;AAKxE,MAAM,sCAAsC;IAC/C;;;;;;KAMC,GACD,YAAY,IAAI,EAAE,OAAO,EAAE,KAAK,CAAE;QAC9B,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG;IACjB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/utils/pathUtils.js"],"sourcesContent":["export function ensureTrailingSlash(value) {\n    return value && !value.endsWith(\"/\") ? `${value}/` : value;\n}\nexport function ensureNoLeadingSlash(value) {\n    return value && value.startsWith(\"/\")\n        ? value.substring(1, value.length)\n        : value;\n}\nexport const removeTrailingSlash = (path) => path.endsWith(\"/\") ? path.slice(0, -1) : path;\n"],"names":[],"mappings":";;;;;AAAO,SAAS,oBAAoB,KAAK;IACrC,OAAO,SAAS,CAAC,MAAM,QAAQ,CAAC,OAAO,GAAG,MAAM,CAAC,CAAC,GAAG;AACzD;AACO,SAAS,qBAAqB,KAAK;IACtC,OAAO,SAAS,MAAM,UAAU,CAAC,OAC3B,MAAM,SAAS,CAAC,GAAG,MAAM,MAAM,IAC/B;AACV;AACO,MAAM,sBAAsB,CAAC,OAAS,KAAK,QAAQ,CAAC,OAAO,KAAK,KAAK,CAAC,GAAG,CAAC,KAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 142, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/utils/url-helpers.js"],"sourcesContent":["export function toSafeRedirect(dangerousRedirect, safeBaseUrl) {\n    let url;\n    try {\n        url = new URL(dangerousRedirect, safeBaseUrl);\n    }\n    catch (e) {\n        return undefined;\n    }\n    if (url.origin === safeBaseUrl.origin) {\n        return url.toString();\n    }\n    return undefined;\n}\n"],"names":[],"mappings":";;;AAAO,SAAS,eAAe,iBAAiB,EAAE,WAAW;IACzD,IAAI;IACJ,IAAI;QACA,MAAM,IAAI,IAAI,mBAAmB;IACrC,EACA,OAAO,GAAG;QACN,OAAO;IACX;IACA,IAAI,IAAI,MAAM,KAAK,YAAY,MAAM,EAAE;QACnC,OAAO,IAAI,QAAQ;IACvB;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 163, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/server/cookies.js"],"sourcesContent":["import { RequestCookies, ResponseCookies } from \"@edge-runtime/cookies\";\nimport hkdf from \"@panva/hkdf\";\nimport * as jose from \"jose\";\nconst ENC = \"A256GCM\";\nconst ALG = \"dir\";\nconst DIGEST = \"sha256\";\nconst BYTE_LENGTH = 32;\nconst ENCRYPTION_INFO = \"JWE CEK\";\nexport async function encrypt(payload, secret, expiration, additionalHeaders) {\n    const encryptionSecret = await hkdf(DIGEST, secret, \"\", ENCRYPTION_INFO, BYTE_LENGTH);\n    const encryptedCookie = await new jose.EncryptJWT(payload)\n        .setProtectedHeader({ enc: ENC, alg: ALG, ...additionalHeaders })\n        .setExpirationTime(expiration)\n        .encrypt(encryptionSecret);\n    return encryptedCookie.toString();\n}\nexport async function decrypt(cookieValue, secret, options) {\n    const encryptionSecret = await hkdf(DIGEST, secret, \"\", ENCRYPTION_INFO, BYTE_LENGTH);\n    const cookie = await jose.jwtDecrypt(cookieValue, encryptionSecret, {\n        ...options,\n        ...{ clockTolerance: 15 }\n    });\n    return cookie;\n}\n/**\n * Derive a signing key from a given secret.\n * This method is used solely to migrate signed, legacy cookies to the new encrypted cookie format (v4+).\n */\nconst signingSecret = (secret) => hkdf(\"sha256\", secret, \"\", \"JWS Cookie Signing\", BYTE_LENGTH);\n/**\n * Verify a signed cookie. If the cookie is valid, the value is returned. Otherwise, undefined is returned.\n * This method is used solely to migrate signed, legacy cookies to the new encrypted cookie format (v4+).\n */\nexport async function verifySigned(k, v, secret) {\n    if (!v) {\n        return undefined;\n    }\n    const [value, signature] = v.split(\".\");\n    const flattenedJWS = {\n        protected: jose.base64url.encode(JSON.stringify({ alg: \"HS256\", b64: false, crit: [\"b64\"] })),\n        payload: `${k}=${value}`,\n        signature\n    };\n    const key = await signingSecret(secret);\n    try {\n        await jose.flattenedVerify(flattenedJWS, key, {\n            algorithms: [\"HS256\"]\n        });\n        return value;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\n/**\n * Sign a cookie value using a secret.\n * This method is used solely to migrate signed, legacy cookies to the new encrypted cookie format (v4+).\n */\nexport async function sign(name, value, secret) {\n    const key = await signingSecret(secret);\n    const { signature } = await new jose.FlattenedSign(new TextEncoder().encode(`${name}=${value}`))\n        .setProtectedHeader({ alg: \"HS256\", b64: false, crit: [\"b64\"] })\n        .sign(key);\n    return `${value}.${signature}`;\n}\nexport { ResponseCookies };\nexport { RequestCookies };\n// Chunked cookies Configuration\nconst MAX_CHUNK_SIZE = 3500; // Slightly under 4KB\nconst CHUNK_PREFIX = \"__\";\nconst CHUNK_INDEX_REGEX = new RegExp(`${CHUNK_PREFIX}(\\\\d+)$`);\nconst LEGACY_CHUNK_INDEX_REGEX = /\\.(\\d+)$/;\n/**\n * Retrieves the index of a cookie based on its name.\n * Supports current format `{name}__{index}` and legacy format `{name}.{index}`.\n *\n * @param name - The name of the cookie.\n * @returns The index of the cookie. Returns undefined if no index is found.\n */\nconst getChunkedCookieIndex = (name, isLegacyCookie) => {\n    const match = isLegacyCookie\n        ? LEGACY_CHUNK_INDEX_REGEX.exec(name)\n        : CHUNK_INDEX_REGEX.exec(name);\n    if (!match) {\n        return undefined;\n    }\n    return parseInt(match[1], 10);\n};\n/**\n * Retrieves all cookies from the request that have names starting with a specific prefix.\n *\n * @param reqCookies - The cookies from the request.\n * @param name - The base name of the cookies to retrieve.\n * @returns An array of cookies that have names starting with the specified prefix.\n */\nconst getAllChunkedCookies = (reqCookies, name, isLegacyCookie) => {\n    const chunkedCookieRegex = new RegExp(isLegacyCookie\n        ? `^${name}${LEGACY_CHUNK_INDEX_REGEX.source}$`\n        : `^${name}${CHUNK_PREFIX}\\\\d+$`);\n    return reqCookies\n        .getAll()\n        .filter((cookie) => chunkedCookieRegex.test(cookie.name));\n};\n/**\n * Sets a cookie with the given name and value, splitting it into chunks if necessary.\n *\n * If the value exceeds the maximum chunk size, it will be split into multiple cookies\n * with names suffixed by a chunk index.\n *\n * @param name - The name of the cookie.\n * @param value - The value to be stored in the cookie.\n * @param options - Options for setting the cookie.\n * @param reqCookies - The request cookies object, used to enable read-after-write in the same request for middleware.\n * @param resCookies - The response cookies object, used to set the cookies in the response.\n */\nexport function setChunkedCookie(name, value, options, reqCookies, resCookies) {\n    const { transient, ...restOptions } = options;\n    const finalOptions = { ...restOptions };\n    if (transient) {\n        delete finalOptions.maxAge;\n    }\n    const valueBytes = new TextEncoder().encode(value).length;\n    // If value fits in a single cookie, set it directly\n    if (valueBytes <= MAX_CHUNK_SIZE) {\n        resCookies.set(name, value, finalOptions);\n        // to enable read-after-write in the same request for middleware\n        reqCookies.set(name, value);\n        // When we are writing a non-chunked cookie, we should remove the chunked cookies\n        getAllChunkedCookies(reqCookies, name).forEach((cookieChunk) => {\n            resCookies.delete(cookieChunk.name);\n            reqCookies.delete(cookieChunk.name);\n        });\n        return;\n    }\n    // Split value into chunks\n    let position = 0;\n    let chunkIndex = 0;\n    while (position < value.length) {\n        const chunk = value.slice(position, position + MAX_CHUNK_SIZE);\n        const chunkName = `${name}${CHUNK_PREFIX}${chunkIndex}`;\n        resCookies.set(chunkName, chunk, finalOptions);\n        // to enable read-after-write in the same request for middleware\n        reqCookies.set(chunkName, chunk);\n        position += MAX_CHUNK_SIZE;\n        chunkIndex++;\n    }\n    // clear unused chunks\n    const chunks = getAllChunkedCookies(reqCookies, name);\n    const chunksToRemove = chunks.length - chunkIndex;\n    if (chunksToRemove > 0) {\n        for (let i = 0; i < chunksToRemove; i++) {\n            const chunkIndexToRemove = chunkIndex + i;\n            const chunkName = `${name}${CHUNK_PREFIX}${chunkIndexToRemove}`;\n            resCookies.delete(chunkName);\n            reqCookies.delete(chunkName);\n        }\n    }\n    // When we have written chunked cookies, we should remove the non-chunked cookie\n    resCookies.delete(name);\n    reqCookies.delete(name);\n}\n/**\n * Retrieves a chunked cookie by its name from the request cookies.\n * If a regular cookie with the given name exists, it returns its value.\n * Otherwise, it attempts to retrieve and combine all chunks of the cookie.\n *\n * @param name - The name of the cookie to retrieve.\n * @param reqCookies - The request cookies object.\n * @returns The combined value of the chunked cookie, or `undefined` if the cookie does not exist or is incomplete.\n */\nexport function getChunkedCookie(name, reqCookies, isLegacyCookie) {\n    // Check if regular cookie exists\n    const cookie = reqCookies.get(name);\n    if (cookie?.value) {\n        // If the base cookie exists, return its value (handles non-chunked case)\n        return cookie.value;\n    }\n    const chunks = getAllChunkedCookies(reqCookies, name, isLegacyCookie).sort(\n    // Extract index from cookie name and sort numerically\n    (first, second) => {\n        return (getChunkedCookieIndex(first.name, isLegacyCookie) -\n            getChunkedCookieIndex(second.name, isLegacyCookie));\n    });\n    if (chunks.length === 0) {\n        return undefined;\n    }\n    // Validate sequence integrity - check for missing chunks\n    const highestIndex = getChunkedCookieIndex(chunks[chunks.length - 1].name, isLegacyCookie);\n    if (chunks.length !== highestIndex + 1) {\n        console.warn(`Incomplete chunked cookie '${name}': Found ${chunks.length} chunks, expected ${highestIndex + 1}`);\n        return undefined;\n    }\n    // Combine all chunks\n    return chunks.map((c) => c.value).join(\"\");\n}\n/**\n * Deletes a chunked cookie and all its associated chunks from the response cookies.\n *\n * @param name - The name of the main cookie to delete.\n * @param reqCookies - The request cookies object containing all cookies from the request.\n * @param resCookies - The response cookies object to manipulate the cookies in the response.\n */\nexport function deleteChunkedCookie(name, reqCookies, resCookies, isLegacyCookie) {\n    // Delete main cookie\n    resCookies.delete(name);\n    getAllChunkedCookies(reqCookies, name, isLegacyCookie).forEach((cookie) => {\n        resCookies.delete(cookie.name); // Delete each filtered cookie\n    });\n}\n/**\n * Unconditionally adds strict cache-control headers to the response.\n *\n * This ensures the response is not cached by CDNs or other shared caches.\n * It is now the caller's responsibility to decide when to call this function.\n *\n * Usage:\n * Call this function whenever a `Set-Cookie` header is being written\n * for session management or any other sensitive data that must not be cached.\n */\nexport function addCacheControlHeadersForSession(res) {\n    res.headers.set(\"Cache-Control\", \"private, no-cache, no-store, must-revalidate, max-age=0\");\n    res.headers.set(\"Pragma\", \"no-cache\");\n    res.headers.set(\"Expires\", \"0\");\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 378, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/server/user.js"],"sourcesContent":["const DEFAULT_ALLOWED_CLAIMS = [\n    \"sub\",\n    \"name\",\n    \"nickname\",\n    \"given_name\",\n    \"family_name\",\n    \"picture\",\n    \"email\",\n    \"email_verified\",\n    \"org_id\"\n];\nexport function filterClaims(claims) {\n    return Object.keys(claims).reduce((acc, key) => {\n        if (DEFAULT_ALLOWED_CLAIMS.includes(key)) {\n            acc[key] = claims[key];\n        }\n        return acc;\n    }, {});\n}\n"],"names":[],"mappings":";;;AAAA,MAAM,yBAAyB;IAC3B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACH;AACM,SAAS,aAAa,MAAM;IAC/B,OAAO,OAAO,IAAI,CAAC,QAAQ,MAAM,CAAC,CAAC,KAAK;QACpC,IAAI,uBAAuB,QAAQ,CAAC,MAAM;YACtC,GAAG,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI;QAC1B;QACA,OAAO;IACX,GAAG,CAAC;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 406, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/server/auth-client.js"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport * as jose from \"jose\";\nimport * as oauth from \"oauth4webapi\";\nimport packageJson from \"../../package.json\";\nimport { AccessTokenError, AccessTokenErrorCode, AccessTokenForConnectionError, AccessTokenForConnectionErrorCode, AuthorizationCodeGrantError, AuthorizationError, BackchannelLogoutError, DiscoveryError, InvalidStateError, MissingStateError, OAuth2Error } from \"../errors\";\nimport { ensureNoLeadingSlash, ensureTrailingSlash, removeTrailingSlash } from \"../utils/pathUtils\";\nimport { toSafeRedirect } from \"../utils/url-helpers\";\nimport { addCacheControlHeadersForSession } from \"./cookies\";\nimport { filterClaims } from \"./user\";\n// params passed to the /authorize endpoint that cannot be overwritten\nconst INTERNAL_AUTHORIZE_PARAMS = [\n    \"client_id\",\n    \"redirect_uri\",\n    \"response_type\",\n    \"code_challenge\",\n    \"code_challenge_method\",\n    \"state\",\n    \"nonce\"\n];\nconst DEFAULT_SCOPES = [\"openid\", \"profile\", \"email\", \"offline_access\"].join(\" \");\n/**\n * A constant representing the grant type for federated connection access token exchange.\n *\n * This grant type is used in OAuth token exchange scenarios where a federated connection\n * access token is required. It is specific to Auth0's implementation and follows the\n * \"urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token\" format.\n */\nconst GRANT_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN = \"urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token\";\n/**\n * Constant representing the subject type for a refresh token.\n * This is used in OAuth 2.0 token exchange to specify that the token being exchanged is a refresh token.\n *\n * @see {@link https://tools.ietf.org/html/rfc8693#section-3.1 RFC 8693 Section 3.1}\n */\nconst SUBJECT_TYPE_REFRESH_TOKEN = \"urn:ietf:params:oauth:token-type:refresh_token\";\n/**\n * A constant representing the token type for federated connection access tokens.\n * This is used to specify the type of token being requested from Auth0.\n *\n * @constant\n * @type {string}\n */\nconst REQUESTED_TOKEN_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN = \"http://auth0.com/oauth/token-type/federated-connection-access-token\";\nfunction createRouteUrl(url, base) {\n    return new URL(ensureNoLeadingSlash(url), ensureTrailingSlash(base));\n}\nexport class AuthClient {\n    constructor(options) {\n        // dependencies\n        this.fetch = options.fetch || fetch;\n        this.jwksCache = options.jwksCache || {};\n        this.allowInsecureRequests = options.allowInsecureRequests ?? false;\n        this.httpOptions = () => {\n            const headers = new Headers();\n            const enableTelemetry = options.enableTelemetry ?? true;\n            const timeout = options.httpTimeout ?? 5000;\n            if (enableTelemetry) {\n                const name = \"nextjs-auth0\";\n                const version = packageJson.version;\n                headers.set(\"User-Agent\", `${name}/${version}`);\n                headers.set(\"Auth0-Client\", encodeBase64(JSON.stringify({\n                    name,\n                    version\n                })));\n            }\n            return {\n                signal: AbortSignal.timeout(timeout),\n                headers\n            };\n        };\n        if (this.allowInsecureRequests && process.env.NODE_ENV === \"production\") {\n            console.warn(\"allowInsecureRequests is enabled in a production environment. This is not recommended.\");\n        }\n        // stores\n        this.transactionStore = options.transactionStore;\n        this.sessionStore = options.sessionStore;\n        // authorization server\n        this.domain = options.domain;\n        this.clientMetadata = { client_id: options.clientId };\n        this.clientSecret = options.clientSecret;\n        this.authorizationParameters = options.authorizationParameters || {\n            scope: DEFAULT_SCOPES\n        };\n        this.pushedAuthorizationRequests =\n            options.pushedAuthorizationRequests ?? false;\n        this.clientAssertionSigningKey = options.clientAssertionSigningKey;\n        this.clientAssertionSigningAlg =\n            options.clientAssertionSigningAlg || \"RS256\";\n        if (!this.authorizationParameters.scope) {\n            this.authorizationParameters.scope = DEFAULT_SCOPES;\n        }\n        const scope = this.authorizationParameters.scope\n            .split(\" \")\n            .map((s) => s.trim());\n        if (!scope.includes(\"openid\")) {\n            throw new Error(\"The 'openid' scope must be included in the set of scopes. See https://auth0.com/docs\");\n        }\n        // application\n        this.appBaseUrl = options.appBaseUrl;\n        this.signInReturnToPath = options.signInReturnToPath || \"/\";\n        // hooks\n        this.beforeSessionSaved = options.beforeSessionSaved;\n        this.onCallback = options.onCallback || this.defaultOnCallback;\n        // routes\n        this.routes = {\n            login: \"/auth/login\",\n            logout: \"/auth/logout\",\n            callback: \"/auth/callback\",\n            backChannelLogout: \"/auth/backchannel-logout\",\n            profile: process.env.NEXT_PUBLIC_PROFILE_ROUTE || \"/auth/profile\",\n            accessToken: process.env.NEXT_PUBLIC_ACCESS_TOKEN_ROUTE || \"/auth/access-token\",\n            ...options.routes\n        };\n        this.enableAccessTokenEndpoint = options.enableAccessTokenEndpoint ?? true;\n    }\n    async handler(req) {\n        const { pathname } = req.nextUrl;\n        const sanitizedPathname = removeTrailingSlash(pathname);\n        const method = req.method;\n        if (method === \"GET\" && sanitizedPathname === this.routes.login) {\n            return this.handleLogin(req);\n        }\n        else if (method === \"GET\" && sanitizedPathname === this.routes.logout) {\n            return this.handleLogout(req);\n        }\n        else if (method === \"GET\" && sanitizedPathname === this.routes.callback) {\n            return this.handleCallback(req);\n        }\n        else if (method === \"GET\" && sanitizedPathname === this.routes.profile) {\n            return this.handleProfile(req);\n        }\n        else if (method === \"GET\" &&\n            sanitizedPathname === this.routes.accessToken &&\n            this.enableAccessTokenEndpoint) {\n            return this.handleAccessToken(req);\n        }\n        else if (method === \"POST\" &&\n            sanitizedPathname === this.routes.backChannelLogout) {\n            return this.handleBackChannelLogout(req);\n        }\n        else {\n            // no auth handler found, simply touch the sessions\n            // TODO: this should only happen if rolling sessions are enabled. Also, we should\n            // try to avoid reading from the DB (for stateful sessions) on every request if possible.\n            const res = NextResponse.next();\n            const session = await this.sessionStore.get(req.cookies);\n            if (session) {\n                // we pass the existing session (containing an `createdAt` timestamp) to the set method\n                // which will update the cookie's `maxAge` property based on the `createdAt` time\n                await this.sessionStore.set(req.cookies, res.cookies, {\n                    ...session\n                });\n                addCacheControlHeadersForSession(res);\n            }\n            return res;\n        }\n    }\n    async startInteractiveLogin(options = {}) {\n        const redirectUri = createRouteUrl(this.routes.callback, this.appBaseUrl); // must be registed with the authorization server\n        let returnTo = this.signInReturnToPath;\n        // Validate returnTo parameter\n        if (options.returnTo) {\n            const safeBaseUrl = new URL(this.authorizationParameters.redirect_uri ||\n                this.appBaseUrl);\n            const sanitizedReturnTo = toSafeRedirect(options.returnTo, safeBaseUrl);\n            if (sanitizedReturnTo) {\n                returnTo = sanitizedReturnTo;\n            }\n        }\n        // Generate PKCE challenges\n        const codeChallengeMethod = \"S256\";\n        const codeVerifier = oauth.generateRandomCodeVerifier();\n        const codeChallenge = await oauth.calculatePKCECodeChallenge(codeVerifier);\n        const state = oauth.generateRandomState();\n        const nonce = oauth.generateRandomNonce();\n        // Construct base authorization parameters\n        const authorizationParams = new URLSearchParams();\n        authorizationParams.set(\"client_id\", this.clientMetadata.client_id);\n        authorizationParams.set(\"redirect_uri\", redirectUri.toString());\n        authorizationParams.set(\"response_type\", \"code\");\n        authorizationParams.set(\"code_challenge\", codeChallenge);\n        authorizationParams.set(\"code_challenge_method\", codeChallengeMethod);\n        authorizationParams.set(\"state\", state);\n        authorizationParams.set(\"nonce\", nonce);\n        const mergedAuthorizationParams = {\n            // any custom params to forward to /authorize defined as configuration\n            ...this.authorizationParameters,\n            // custom parameters passed in via the query params to ensure only the confidential client can set them\n            ...options.authorizationParameters\n        };\n        Object.entries(mergedAuthorizationParams).forEach(([key, val]) => {\n            if (!INTERNAL_AUTHORIZE_PARAMS.includes(key) && val != null) {\n                authorizationParams.set(key, String(val));\n            }\n        });\n        // Prepare transaction state\n        const transactionState = {\n            nonce,\n            maxAge: this.authorizationParameters.max_age,\n            codeVerifier,\n            responseType: \"code\",\n            state,\n            returnTo\n        };\n        // Generate authorization URL with PAR handling\n        const [error, authorizationUrl] = await this.authorizationUrl(authorizationParams);\n        if (error) {\n            return new NextResponse(\"An error occured while trying to initiate the login request.\", {\n                status: 500\n            });\n        }\n        // Set response and save transaction\n        const res = NextResponse.redirect(authorizationUrl.toString());\n        await this.transactionStore.save(res.cookies, transactionState);\n        return res;\n    }\n    async handleLogin(req) {\n        const searchParams = Object.fromEntries(req.nextUrl.searchParams.entries());\n        const options = {\n            // SECURITY CRITICAL: Only forward query params when PAR is disabled\n            authorizationParameters: !this.pushedAuthorizationRequests\n                ? searchParams\n                : {},\n            returnTo: searchParams.returnTo\n        };\n        return this.startInteractiveLogin(options);\n    }\n    async handleLogout(req) {\n        const session = await this.sessionStore.get(req.cookies);\n        const [discoveryError, authorizationServerMetadata] = await this.discoverAuthorizationServerMetadata();\n        if (discoveryError) {\n            return new NextResponse(\"An error occured while trying to initiate the logout request.\", {\n                status: 500\n            });\n        }\n        const returnTo = req.nextUrl.searchParams.get(\"returnTo\") || this.appBaseUrl;\n        if (!authorizationServerMetadata.end_session_endpoint) {\n            // the Auth0 client does not have RP-initiated logout enabled, redirect to the `/v2/logout` endpoint\n            console.warn(\"The Auth0 client does not have RP-initiated logout enabled, the user will be redirected to the `/v2/logout` endpoint instead. Learn how to enable it here: https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0#enable-endpoint-discovery\");\n            const url = new URL(\"/v2/logout\", this.issuer);\n            url.searchParams.set(\"returnTo\", returnTo);\n            url.searchParams.set(\"client_id\", this.clientMetadata.client_id);\n            const res = NextResponse.redirect(url);\n            await this.sessionStore.delete(req.cookies, res.cookies);\n            // Clear any orphaned transaction cookies\n            await this.transactionStore.deleteAll(req.cookies, res.cookies);\n            return res;\n        }\n        const url = new URL(authorizationServerMetadata.end_session_endpoint);\n        url.searchParams.set(\"client_id\", this.clientMetadata.client_id);\n        url.searchParams.set(\"post_logout_redirect_uri\", returnTo);\n        if (session?.internal.sid) {\n            url.searchParams.set(\"logout_hint\", session.internal.sid);\n        }\n        if (session?.tokenSet.idToken) {\n            url.searchParams.set(\"id_token_hint\", session?.tokenSet.idToken);\n        }\n        const res = NextResponse.redirect(url);\n        await this.sessionStore.delete(req.cookies, res.cookies);\n        addCacheControlHeadersForSession(res);\n        // Clear any orphaned transaction cookies\n        await this.transactionStore.deleteAll(req.cookies, res.cookies);\n        return res;\n    }\n    async handleCallback(req) {\n        const state = req.nextUrl.searchParams.get(\"state\");\n        if (!state) {\n            return this.onCallback(new MissingStateError(), {}, null);\n        }\n        const transactionStateCookie = await this.transactionStore.get(req.cookies, state);\n        if (!transactionStateCookie) {\n            return this.onCallback(new InvalidStateError(), {}, null);\n        }\n        const transactionState = transactionStateCookie.payload;\n        const onCallbackCtx = {\n            returnTo: transactionState.returnTo\n        };\n        const [discoveryError, authorizationServerMetadata] = await this.discoverAuthorizationServerMetadata();\n        if (discoveryError) {\n            return this.onCallback(discoveryError, onCallbackCtx, null);\n        }\n        let codeGrantParams;\n        try {\n            codeGrantParams = oauth.validateAuthResponse(authorizationServerMetadata, this.clientMetadata, req.nextUrl.searchParams, transactionState.state);\n        }\n        catch (e) {\n            return this.onCallback(new AuthorizationError({\n                cause: new OAuth2Error({\n                    code: e.error,\n                    message: e.error_description\n                })\n            }), onCallbackCtx, null);\n        }\n        const redirectUri = createRouteUrl(this.routes.callback, this.appBaseUrl); // must be registed with the authorization server\n        const codeGrantResponse = await oauth.authorizationCodeGrantRequest(authorizationServerMetadata, this.clientMetadata, await this.getClientAuth(), codeGrantParams, redirectUri.toString(), transactionState.codeVerifier, {\n            ...this.httpOptions(),\n            [oauth.customFetch]: this.fetch,\n            [oauth.allowInsecureRequests]: this.allowInsecureRequests\n        });\n        let oidcRes;\n        try {\n            oidcRes = await oauth.processAuthorizationCodeResponse(authorizationServerMetadata, this.clientMetadata, codeGrantResponse, {\n                expectedNonce: transactionState.nonce,\n                maxAge: transactionState.maxAge,\n                requireIdToken: true\n            });\n        }\n        catch (e) {\n            return this.onCallback(new AuthorizationCodeGrantError({\n                cause: new OAuth2Error({\n                    code: e.error,\n                    message: e.error_description\n                })\n            }), onCallbackCtx, null);\n        }\n        const idTokenClaims = oauth.getValidatedIdTokenClaims(oidcRes);\n        let session = {\n            user: idTokenClaims,\n            tokenSet: {\n                accessToken: oidcRes.access_token,\n                idToken: oidcRes.id_token,\n                scope: oidcRes.scope,\n                refreshToken: oidcRes.refresh_token,\n                expiresAt: Math.floor(Date.now() / 1000) + Number(oidcRes.expires_in)\n            },\n            internal: {\n                sid: idTokenClaims.sid,\n                createdAt: Math.floor(Date.now() / 1000)\n            }\n        };\n        const res = await this.onCallback(null, onCallbackCtx, session);\n        if (this.beforeSessionSaved) {\n            const updatedSession = await this.beforeSessionSaved(session, oidcRes.id_token ?? null);\n            session = {\n                ...updatedSession,\n                internal: session.internal\n            };\n        }\n        else {\n            session.user = filterClaims(idTokenClaims);\n        }\n        await this.sessionStore.set(req.cookies, res.cookies, session, true);\n        addCacheControlHeadersForSession(res);\n        await this.transactionStore.delete(res.cookies, state);\n        return res;\n    }\n    async handleProfile(req) {\n        const session = await this.sessionStore.get(req.cookies);\n        if (!session) {\n            return new NextResponse(null, {\n                status: 401\n            });\n        }\n        const res = NextResponse.json(session?.user);\n        addCacheControlHeadersForSession(res);\n        return res;\n    }\n    async handleAccessToken(req) {\n        const session = await this.sessionStore.get(req.cookies);\n        if (!session) {\n            return NextResponse.json({\n                error: {\n                    message: \"The user does not have an active session.\",\n                    code: AccessTokenErrorCode.MISSING_SESSION\n                }\n            }, {\n                status: 401\n            });\n        }\n        const [error, updatedTokenSet] = await this.getTokenSet(session.tokenSet);\n        if (error) {\n            return NextResponse.json({\n                error: {\n                    message: error.message,\n                    code: error.code\n                }\n            }, {\n                status: 401\n            });\n        }\n        const res = NextResponse.json({\n            token: updatedTokenSet.accessToken,\n            scope: updatedTokenSet.scope,\n            expires_at: updatedTokenSet.expiresAt\n        });\n        if (updatedTokenSet.accessToken !== session.tokenSet.accessToken ||\n            updatedTokenSet.refreshToken !== session.tokenSet.refreshToken ||\n            updatedTokenSet.expiresAt !== session.tokenSet.expiresAt) {\n            await this.sessionStore.set(req.cookies, res.cookies, {\n                ...session,\n                tokenSet: updatedTokenSet\n            });\n            addCacheControlHeadersForSession(res);\n        }\n        return res;\n    }\n    async handleBackChannelLogout(req) {\n        if (!this.sessionStore.store) {\n            return new NextResponse(\"A session data store is not configured.\", {\n                status: 500\n            });\n        }\n        if (!this.sessionStore.store.deleteByLogoutToken) {\n            return new NextResponse(\"Back-channel logout is not supported by the session data store.\", {\n                status: 500\n            });\n        }\n        const body = new URLSearchParams(await req.text());\n        const logoutToken = body.get(\"logout_token\");\n        if (!logoutToken) {\n            return new NextResponse(\"Missing `logout_token` in the request body.\", {\n                status: 400\n            });\n        }\n        const [error, logoutTokenClaims] = await this.verifyLogoutToken(logoutToken);\n        if (error) {\n            return new NextResponse(error.message, {\n                status: 400\n            });\n        }\n        await this.sessionStore.store.deleteByLogoutToken(logoutTokenClaims);\n        return new NextResponse(null, {\n            status: 204\n        });\n    }\n    /**\n     * getTokenSet returns a valid token set. If the access token has expired, it will attempt to\n     * refresh it using the refresh token, if available.\n     */\n    async getTokenSet(tokenSet, forceRefresh) {\n        // the access token has expired but we do not have a refresh token\n        if (!tokenSet.refreshToken && tokenSet.expiresAt <= Date.now() / 1000) {\n            return [\n                new AccessTokenError(AccessTokenErrorCode.MISSING_REFRESH_TOKEN, \"The access token has expired and a refresh token was not provided. The user needs to re-authenticate.\"),\n                null\n            ];\n        }\n        if (tokenSet.refreshToken) {\n            // either the access token has expired or we are forcing a refresh\n            if (forceRefresh || tokenSet.expiresAt <= Date.now() / 1000) {\n                const [discoveryError, authorizationServerMetadata] = await this.discoverAuthorizationServerMetadata();\n                if (discoveryError) {\n                    console.error(discoveryError);\n                    return [discoveryError, null];\n                }\n                const refreshTokenRes = await oauth.refreshTokenGrantRequest(authorizationServerMetadata, this.clientMetadata, await this.getClientAuth(), tokenSet.refreshToken, {\n                    ...this.httpOptions(),\n                    [oauth.customFetch]: this.fetch,\n                    [oauth.allowInsecureRequests]: this.allowInsecureRequests\n                });\n                let oauthRes;\n                try {\n                    oauthRes = await oauth.processRefreshTokenResponse(authorizationServerMetadata, this.clientMetadata, refreshTokenRes);\n                }\n                catch (e) {\n                    console.error(e);\n                    return [\n                        new AccessTokenError(AccessTokenErrorCode.FAILED_TO_REFRESH_TOKEN, \"The access token has expired and there was an error while trying to refresh it. Check the server logs for more information.\"),\n                        null\n                    ];\n                }\n                const accessTokenExpiresAt = Math.floor(Date.now() / 1000) + Number(oauthRes.expires_in);\n                const updatedTokenSet = {\n                    ...tokenSet, // contains the existing `iat` claim to maintain the session lifetime\n                    accessToken: oauthRes.access_token,\n                    idToken: oauthRes.id_token,\n                    expiresAt: accessTokenExpiresAt\n                };\n                if (oauthRes.refresh_token) {\n                    // refresh token rotation is enabled, persist the new refresh token from the response\n                    updatedTokenSet.refreshToken = oauthRes.refresh_token;\n                }\n                else {\n                    // we did not get a refresh token back, keep the current long-lived refresh token around\n                    updatedTokenSet.refreshToken = tokenSet.refreshToken;\n                }\n                return [null, updatedTokenSet];\n            }\n        }\n        return [null, tokenSet];\n    }\n    async discoverAuthorizationServerMetadata() {\n        if (this.authorizationServerMetadata) {\n            return [null, this.authorizationServerMetadata];\n        }\n        const issuer = new URL(this.issuer);\n        try {\n            const authorizationServerMetadata = await oauth\n                .discoveryRequest(issuer, {\n                ...this.httpOptions(),\n                [oauth.customFetch]: this.fetch,\n                [oauth.allowInsecureRequests]: this.allowInsecureRequests\n            })\n                .then((response) => oauth.processDiscoveryResponse(issuer, response));\n            this.authorizationServerMetadata = authorizationServerMetadata;\n            return [null, authorizationServerMetadata];\n        }\n        catch (e) {\n            console.error(`An error occured while performing the discovery request. Please make sure the AUTH0_DOMAIN environment variable is correctly configured — the format must be 'example.us.auth0.com'. issuer=${issuer.toString()}, error:`, e);\n            return [\n                new DiscoveryError(\"Discovery failed for the OpenID Connect configuration.\"),\n                null\n            ];\n        }\n    }\n    async defaultOnCallback(error, ctx) {\n        if (error) {\n            return new NextResponse(error.message, {\n                status: 500\n            });\n        }\n        const res = NextResponse.redirect(createRouteUrl(ctx.returnTo || \"/\", this.appBaseUrl));\n        return res;\n    }\n    async verifyLogoutToken(logoutToken) {\n        const [discoveryError, authorizationServerMetadata] = await this.discoverAuthorizationServerMetadata();\n        if (discoveryError) {\n            return [discoveryError, null];\n        }\n        // only `RS256` is supported for logout tokens\n        const ID_TOKEN_SIGNING_ALG = \"RS256\";\n        const keyInput = jose.createRemoteJWKSet(new URL(authorizationServerMetadata.jwks_uri), {\n            [jose.jwksCache]: this.jwksCache\n        });\n        const { payload } = await jose.jwtVerify(logoutToken, keyInput, {\n            issuer: authorizationServerMetadata.issuer,\n            audience: this.clientMetadata.client_id,\n            algorithms: [ID_TOKEN_SIGNING_ALG],\n            requiredClaims: [\"iat\"]\n        });\n        if (!(\"sid\" in payload) && !(\"sub\" in payload)) {\n            return [\n                new BackchannelLogoutError('either \"sid\" or \"sub\" (or both) claims must be present'),\n                null\n            ];\n        }\n        if (\"sid\" in payload && typeof payload.sid !== \"string\") {\n            return [new BackchannelLogoutError('\"sid\" claim must be a string'), null];\n        }\n        if (\"sub\" in payload && typeof payload.sub !== \"string\") {\n            return [new BackchannelLogoutError('\"sub\" claim must be a string'), null];\n        }\n        if (\"nonce\" in payload) {\n            return [new BackchannelLogoutError('\"nonce\" claim is prohibited'), null];\n        }\n        if (!(\"events\" in payload)) {\n            return [new BackchannelLogoutError('\"events\" claim is missing'), null];\n        }\n        if (typeof payload.events !== \"object\" || payload.events === null) {\n            return [\n                new BackchannelLogoutError('\"events\" claim must be an object'),\n                null\n            ];\n        }\n        if (!(\"http://schemas.openid.net/event/backchannel-logout\" in payload.events)) {\n            return [\n                new BackchannelLogoutError('\"http://schemas.openid.net/event/backchannel-logout\" member is missing in the \"events\" claim'),\n                null\n            ];\n        }\n        if (typeof payload.events[\"http://schemas.openid.net/event/backchannel-logout\"] !== \"object\") {\n            return [\n                new BackchannelLogoutError('\"http://schemas.openid.net/event/backchannel-logout\" member in the \"events\" claim must be an object'),\n                null\n            ];\n        }\n        return [\n            null,\n            {\n                sid: payload.sid,\n                sub: payload.sub\n            }\n        ];\n    }\n    async authorizationUrl(params) {\n        const [discoveryError, authorizationServerMetadata] = await this.discoverAuthorizationServerMetadata();\n        if (discoveryError) {\n            return [discoveryError, null];\n        }\n        if (this.pushedAuthorizationRequests &&\n            !authorizationServerMetadata.pushed_authorization_request_endpoint) {\n            console.error(\"The Auth0 tenant does not have pushed authorization requests enabled. Learn how to enable it here: https://auth0.com/docs/get-started/applications/configure-par\");\n            return [\n                new Error(\"The authorization server does not support pushed authorization requests.\"),\n                null\n            ];\n        }\n        const authorizationUrl = new URL(authorizationServerMetadata.authorization_endpoint);\n        if (this.pushedAuthorizationRequests) {\n            // push the request params to the authorization server\n            const response = await oauth.pushedAuthorizationRequest(authorizationServerMetadata, this.clientMetadata, await this.getClientAuth(), params, {\n                ...this.httpOptions(),\n                [oauth.customFetch]: this.fetch,\n                [oauth.allowInsecureRequests]: this.allowInsecureRequests\n            });\n            let parRes;\n            try {\n                parRes = await oauth.processPushedAuthorizationResponse(authorizationServerMetadata, this.clientMetadata, response);\n            }\n            catch (e) {\n                return [\n                    new AuthorizationError({\n                        cause: new OAuth2Error({\n                            code: e.error,\n                            message: e.error_description\n                        }),\n                        message: \"An error occured while pushing the authorization request.\"\n                    }),\n                    null\n                ];\n            }\n            authorizationUrl.searchParams.set(\"request_uri\", parRes.request_uri);\n            authorizationUrl.searchParams.set(\"client_id\", this.clientMetadata.client_id);\n            return [null, authorizationUrl];\n        }\n        // append the query parameters to the authorization URL for the normal flow\n        authorizationUrl.search = params.toString();\n        return [null, authorizationUrl];\n    }\n    async getClientAuth() {\n        if (!this.clientSecret && !this.clientAssertionSigningKey) {\n            throw new Error(\"The client secret or client assertion signing key must be provided.\");\n        }\n        let clientPrivateKey = this.clientAssertionSigningKey;\n        if (clientPrivateKey && !(clientPrivateKey instanceof CryptoKey)) {\n            clientPrivateKey = await jose.importPKCS8(clientPrivateKey, this.clientAssertionSigningAlg);\n        }\n        return clientPrivateKey\n            ? oauth.PrivateKeyJwt(clientPrivateKey)\n            : oauth.ClientSecretPost(this.clientSecret);\n    }\n    get issuer() {\n        return this.domain.startsWith(\"http://\") ||\n            this.domain.startsWith(\"https://\")\n            ? this.domain\n            : `https://${this.domain}`;\n    }\n    /**\n     * Exchanges a refresh token for an access token for a connection.\n     *\n     * This method performs a token exchange using the provided refresh token and connection details.\n     * It first checks if the refresh token is present in the `tokenSet`. If not, it returns an error.\n     * Then, it constructs the necessary parameters for the token exchange request and performs\n     * the request to the authorization server's token endpoint.\n     *\n     * @returns {Promise<[AccessTokenForConnectionError, null] | [null, ConnectionTokenSet]>} A promise that resolves to a tuple.\n     *          The first element is either an `AccessTokenForConnectionError` if an error occurred, or `null` if the request was successful.\n     *          The second element is either `null` if an error occurred, or a `ConnectionTokenSet` object\n     *          containing the access token, expiration time, and scope if the request was successful.\n     *\n     * @throws {AccessTokenForConnectionError} If the refresh token is missing or if there is an error during the token exchange process.\n     */\n    async getConnectionTokenSet(tokenSet, connectionTokenSet, options) {\n        // If we do not have a refresh token\n        // and we do not have a connection token set in the cache or the one we have is expired,\n        // there is noting to retrieve and we return an error.\n        if (!tokenSet.refreshToken &&\n            (!connectionTokenSet || connectionTokenSet.expiresAt <= Date.now() / 1000)) {\n            return [\n                new AccessTokenForConnectionError(AccessTokenForConnectionErrorCode.MISSING_REFRESH_TOKEN, \"A refresh token was not present, Connection Access Token requires a refresh token. The user needs to re-authenticate.\"),\n                null\n            ];\n        }\n        // If we do have a refresh token,\n        // and we do not have a connection token set in the cache or the one we have is expired,\n        // we need to exchange the refresh token for a connection access token.\n        if (tokenSet.refreshToken &&\n            (!connectionTokenSet || connectionTokenSet.expiresAt <= Date.now() / 1000)) {\n            const params = new URLSearchParams();\n            params.append(\"connection\", options.connection);\n            params.append(\"subject_token_type\", SUBJECT_TYPE_REFRESH_TOKEN);\n            params.append(\"subject_token\", tokenSet.refreshToken);\n            params.append(\"requested_token_type\", REQUESTED_TOKEN_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN);\n            if (options.login_hint) {\n                params.append(\"login_hint\", options.login_hint);\n            }\n            const [discoveryError, authorizationServerMetadata] = await this.discoverAuthorizationServerMetadata();\n            if (discoveryError) {\n                console.error(discoveryError);\n                return [discoveryError, null];\n            }\n            const httpResponse = await oauth.genericTokenEndpointRequest(authorizationServerMetadata, this.clientMetadata, await this.getClientAuth(), GRANT_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN, params, {\n                [oauth.customFetch]: this.fetch,\n                [oauth.allowInsecureRequests]: this.allowInsecureRequests\n            });\n            let tokenEndpointResponse;\n            try {\n                tokenEndpointResponse = await oauth.processGenericTokenEndpointResponse(authorizationServerMetadata, this.clientMetadata, httpResponse);\n            }\n            catch (err) {\n                console.error(err);\n                return [\n                    new AccessTokenForConnectionError(AccessTokenForConnectionErrorCode.FAILED_TO_EXCHANGE, \"There was an error trying to exchange the refresh token for a connection access token. Check the server logs for more information.\", new OAuth2Error({\n                        code: err.error,\n                        message: err.error_description\n                    })),\n                    null\n                ];\n            }\n            return [\n                null,\n                {\n                    accessToken: tokenEndpointResponse.access_token,\n                    expiresAt: Math.floor(Date.now() / 1000) +\n                        Number(tokenEndpointResponse.expires_in),\n                    scope: tokenEndpointResponse.scope,\n                    connection: options.connection\n                }\n            ];\n        }\n        return [null, connectionTokenSet];\n    }\n}\nconst encodeBase64 = (input) => {\n    const unencoded = new TextEncoder().encode(input);\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {\n        arr.push(\n        // @ts-expect-error Argument of type 'Uint8Array' is not assignable to parameter of type 'number[]'.\n        String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(\"\"));\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1164, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/server/session/abstract-session-store.js"],"sourcesContent":["const SESSION_COOKIE_NAME = \"__session\";\nexport class AbstractSessionStore {\n    constructor({ secret, rolling = true, absoluteDuration = 60 * 60 * 24 * 3, // 3 days in seconds\n    inactivityDuration = 60 * 60 * 24 * 1, // 1 day in seconds\n    store, cookieOptions }) {\n        this.secret = secret;\n        this.rolling = rolling;\n        this.absoluteDuration = absoluteDuration;\n        this.inactivityDuration = inactivityDuration;\n        this.store = store;\n        this.sessionCookieName = cookieOptions?.name ?? SESSION_COOKIE_NAME;\n        this.cookieConfig = {\n            httpOnly: true,\n            sameSite: cookieOptions?.sameSite ?? \"lax\",\n            secure: cookieOptions?.secure ?? false,\n            path: cookieOptions?.path ?? \"/\",\n            domain: cookieOptions?.domain,\n            transient: cookieOptions?.transient\n        };\n    }\n    /**\n     * epoch returns the time since unix epoch in seconds.\n     */\n    epoch() {\n        return (Date.now() / 1000) | 0;\n    }\n    /**\n     * calculateMaxAge calculates the max age of the session based on createdAt and the rolling and absolute durations.\n     */\n    calculateMaxAge(createdAt) {\n        if (!this.rolling) {\n            return this.absoluteDuration;\n        }\n        const updatedAt = this.epoch();\n        const expiresAt = Math.min(updatedAt + this.inactivityDuration, createdAt + this.absoluteDuration);\n        const maxAge = expiresAt - this.epoch();\n        return maxAge > 0 ? maxAge : 0;\n    }\n}\n"],"names":[],"mappings":";;;AAAA,MAAM,sBAAsB;AACrB,MAAM;IACT,YAAY,EAAE,MAAM,EAAE,UAAU,IAAI,EAAE,mBAAmB,KAAK,KAAK,KAAK,CAAC,EACzE,qBAAqB,KAAK,KAAK,KAAK,CAAC,EACrC,KAAK,EAAE,aAAa,EAAE,CAAE;QACpB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,gBAAgB,GAAG;QACxB,IAAI,CAAC,kBAAkB,GAAG;QAC1B,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,iBAAiB,GAAG,eAAe,QAAQ;QAChD,IAAI,CAAC,YAAY,GAAG;YAChB,UAAU;YACV,UAAU,eAAe,YAAY;YACrC,QAAQ,eAAe,UAAU;YACjC,MAAM,eAAe,QAAQ;YAC7B,QAAQ,eAAe;YACvB,WAAW,eAAe;QAC9B;IACJ;IACA;;KAEC,GACD,QAAQ;QACJ,OAAO,AAAC,KAAK,GAAG,KAAK,OAAQ;IACjC;IACA;;KAEC,GACD,gBAAgB,SAAS,EAAE;QACvB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,OAAO,IAAI,CAAC,gBAAgB;QAChC;QACA,MAAM,YAAY,IAAI,CAAC,KAAK;QAC5B,MAAM,YAAY,KAAK,GAAG,CAAC,YAAY,IAAI,CAAC,kBAAkB,EAAE,YAAY,IAAI,CAAC,gBAAgB;QACjG,MAAM,SAAS,YAAY,IAAI,CAAC,KAAK;QACrC,OAAO,SAAS,IAAI,SAAS;IACjC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1208, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/server/session/normalize-session.js"],"sourcesContent":["export const LEGACY_COOKIE_NAME = \"appSession\";\n/**\n * The user's session.\n */\nexport class LegacySession {\n    constructor(user) {\n        this.user = user;\n    }\n}\nexport function normalizeStatelessSession(sessionCookie) {\n    // if the session cookie has an `iat` claim in the protected header, it's a legacy cookie\n    // otherwise, it's the new session cookie format and no transformation is needed\n    if (sessionCookie.protectedHeader.iat) {\n        const legacySession = sessionCookie;\n        return convertFromLegacy(legacySession.protectedHeader, legacySession.payload);\n    }\n    return sessionCookie.payload;\n}\nexport function normalizeStatefulSession(sessionData) {\n    if (sessionData.header?.iat) {\n        const legacySession = sessionData;\n        return convertFromLegacy(legacySession.header, legacySession.data);\n    }\n    return sessionData;\n}\nfunction convertFromLegacy(header, session) {\n    const userClaims = session.user;\n    return {\n        user: userClaims,\n        tokenSet: {\n            idToken: session.idToken ?? undefined,\n            accessToken: session.accessToken ?? undefined,\n            scope: session.accessTokenScope,\n            refreshToken: session.refreshToken,\n            expiresAt: session.accessTokenExpiresAt\n        },\n        internal: {\n            sid: userClaims.sid,\n            createdAt: header.iat\n        }\n    };\n}\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,qBAAqB;AAI3B,MAAM;IACT,YAAY,IAAI,CAAE;QACd,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ;AACO,SAAS,0BAA0B,aAAa;IACnD,yFAAyF;IACzF,gFAAgF;IAChF,IAAI,cAAc,eAAe,CAAC,GAAG,EAAE;QACnC,MAAM,gBAAgB;QACtB,OAAO,kBAAkB,cAAc,eAAe,EAAE,cAAc,OAAO;IACjF;IACA,OAAO,cAAc,OAAO;AAChC;AACO,SAAS,yBAAyB,WAAW;IAChD,IAAI,YAAY,MAAM,EAAE,KAAK;QACzB,MAAM,gBAAgB;QACtB,OAAO,kBAAkB,cAAc,MAAM,EAAE,cAAc,IAAI;IACrE;IACA,OAAO;AACX;AACA,SAAS,kBAAkB,MAAM,EAAE,OAAO;IACtC,MAAM,aAAa,QAAQ,IAAI;IAC/B,OAAO;QACH,MAAM;QACN,UAAU;YACN,SAAS,QAAQ,OAAO,IAAI;YAC5B,aAAa,QAAQ,WAAW,IAAI;YACpC,OAAO,QAAQ,gBAAgB;YAC/B,cAAc,QAAQ,YAAY;YAClC,WAAW,QAAQ,oBAAoB;QAC3C;QACA,UAAU;YACN,KAAK,WAAW,GAAG;YACnB,WAAW,OAAO,GAAG;QACzB;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1259, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/server/session/stateful-session-store.js"],"sourcesContent":["import * as cookies from \"../cookies\";\nimport { AbstractSessionStore } from \"./abstract-session-store\";\nimport { LEGACY_COOKIE_NAME, normalizeStatefulSession } from \"./normalize-session\";\nconst generateId = () => {\n    const bytes = new Uint8Array(16);\n    crypto.getRandomValues(bytes);\n    return Array.from(bytes)\n        .map((b) => b.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n};\nexport class StatefulSessionStore extends AbstractSessionStore {\n    constructor({ secret, store, rolling, absoluteDuration, inactivityDuration, cookieOptions }) {\n        super({\n            secret,\n            rolling,\n            absoluteDuration,\n            inactivityDuration,\n            cookieOptions\n        });\n        this.store = store;\n    }\n    async get(reqCookies) {\n        const cookie = reqCookies.get(this.sessionCookieName) ||\n            reqCookies.get(LEGACY_COOKIE_NAME);\n        if (!cookie || !cookie.value) {\n            return null;\n        }\n        // we attempt to extract the session ID by decrypting the cookie value (assuming it's a JWE, v4+) first\n        // if that fails, we attempt to verify the cookie value as a signed cookie (legacy, v3-)\n        // if both fail, we return null\n        // this ensures that v3 sessions are respected and can be transparently rolled over to v4+ sessions\n        let sessionId = null;\n        try {\n            const { payload: sessionCookie } = await cookies.decrypt(cookie.value, this.secret);\n            sessionId = sessionCookie.id;\n        }\n        catch (e) {\n            // the session cookie could not be decrypted, try to verify if it's a legacy session\n            if (e.code === \"ERR_JWE_INVALID\") {\n                const legacySessionId = await cookies.verifySigned(cookie.name, cookie.value, this.secret);\n                if (!legacySessionId) {\n                    return null;\n                }\n                sessionId = legacySessionId;\n            }\n        }\n        if (!sessionId) {\n            return null;\n        }\n        const session = await this.store.get(sessionId);\n        if (!session) {\n            return null;\n        }\n        return normalizeStatefulSession(session);\n    }\n    async set(reqCookies, resCookies, session, isNew = false) {\n        // check if a session already exists. If so, maintain the existing session ID\n        let sessionId = null;\n        const cookieValue = reqCookies.get(this.sessionCookieName)?.value;\n        if (cookieValue) {\n            const { payload: sessionCookie } = await cookies.decrypt(cookieValue, this.secret);\n            sessionId = sessionCookie.id;\n        }\n        // if this is a new session created by a new login we need to remove the old session\n        // from the store and regenerate the session ID to prevent session fixation.\n        if (sessionId && isNew) {\n            await this.store.delete(sessionId);\n            sessionId = generateId();\n        }\n        if (!sessionId) {\n            sessionId = generateId();\n        }\n        const maxAge = this.calculateMaxAge(session.internal.createdAt);\n        const expiration = Date.now() / 1000 + maxAge;\n        const jwe = await cookies.encrypt({\n            id: sessionId\n        }, this.secret, expiration);\n        resCookies.set(this.sessionCookieName, jwe.toString(), {\n            ...this.cookieConfig,\n            maxAge\n        });\n        await this.store.set(sessionId, session);\n        // to enable read-after-write in the same request for middleware\n        reqCookies.set(this.sessionCookieName, jwe.toString());\n        // Any existing v3 cookie can also be deleted once we have set a v4 cookie.\n        // In stateful sessions, we do not have to worry about chunking.\n        if (this.sessionCookieName !== LEGACY_COOKIE_NAME &&\n            reqCookies.has(LEGACY_COOKIE_NAME)) {\n            resCookies.delete(LEGACY_COOKIE_NAME);\n        }\n    }\n    async delete(reqCookies, resCookies) {\n        const cookieValue = reqCookies.get(this.sessionCookieName)?.value;\n        await resCookies.delete(this.sessionCookieName);\n        if (!cookieValue) {\n            return;\n        }\n        const { payload: session } = await cookies.decrypt(cookieValue, this.secret);\n        await this.store.delete(session.id);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1368, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/server/session/stateless-session-store.js"],"sourcesContent":["import * as cookies from \"../cookies\";\nimport { AbstractSessionStore } from \"./abstract-session-store\";\nimport { LEGACY_COOKIE_NAME, normalizeStatelessSession } from \"./normalize-session\";\nexport class StatelessSessionStore extends AbstractSessionStore {\n    constructor({ secret, rolling, absoluteDuration, inactivityDuration, cookieOptions }) {\n        super({\n            secret,\n            rolling,\n            absoluteDuration,\n            inactivityDuration,\n            cookieOptions\n        });\n        this.connectionTokenSetsCookieName = \"__FC\";\n    }\n    async get(reqCookies) {\n        const cookieValue = cookies.getChunkedCookie(this.sessionCookieName, reqCookies) ??\n            cookies.getChunkedCookie(LEGACY_COOKIE_NAME, reqCookies, true);\n        if (!cookieValue) {\n            return null;\n        }\n        const originalSession = await cookies.decrypt(cookieValue, this.secret);\n        const normalizedStatelessSession = normalizeStatelessSession(originalSession);\n        // As connection access tokens are stored in seperate cookies,\n        // we need to get all cookies and only use those that are prefixed with `this.connectionTokenSetsCookieName`\n        const connectionTokenSets = await Promise.all(this.getConnectionTokenSetsCookies(reqCookies).map((cookie) => cookies.decrypt(cookie.value, this.secret)));\n        return {\n            ...normalizedStatelessSession,\n            // Ensure that when there are no connection token sets, we omit the property.\n            ...(connectionTokenSets.length\n                ? {\n                    connectionTokenSets: connectionTokenSets.map((tokenSet) => tokenSet.payload)\n                }\n                : {})\n        };\n    }\n    /**\n     * save adds the encrypted session cookie as a `Set-Cookie` header.\n     */\n    async set(reqCookies, resCookies, session) {\n        const { connectionTokenSets, ...originalSession } = session;\n        const maxAge = this.calculateMaxAge(session.internal.createdAt);\n        const expiration = Math.floor(Date.now() / 1000) + maxAge;\n        const jwe = await cookies.encrypt(originalSession, this.secret, expiration);\n        const cookieValue = jwe.toString();\n        const options = {\n            ...this.cookieConfig,\n            maxAge\n        };\n        cookies.setChunkedCookie(this.sessionCookieName, cookieValue, options, reqCookies, resCookies);\n        // Store connection access tokens, each in its own cookie\n        if (connectionTokenSets?.length) {\n            await Promise.all(connectionTokenSets.map((connectionTokenSet, index) => this.storeInCookie(reqCookies, resCookies, connectionTokenSet, `${this.connectionTokenSetsCookieName}_${index}`, maxAge)));\n        }\n        // Any existing v3 cookie can be deleted as soon as we have set a v4 cookie.\n        // In stateless sessions, we do have to ensure we delete all chunks.\n        cookies.deleteChunkedCookie(LEGACY_COOKIE_NAME, reqCookies, resCookies, true);\n    }\n    async delete(reqCookies, resCookies) {\n        cookies.deleteChunkedCookie(this.sessionCookieName, reqCookies, resCookies);\n        this.getConnectionTokenSetsCookies(reqCookies).forEach((cookie) => resCookies.delete(cookie.name));\n    }\n    async storeInCookie(reqCookies, resCookies, session, cookieName, maxAge) {\n        const expiration = Math.floor(Date.now() / 1000 + maxAge);\n        const jwe = await cookies.encrypt(session, this.secret, expiration);\n        const cookieValue = jwe.toString();\n        resCookies.set(cookieName, jwe.toString(), {\n            ...this.cookieConfig,\n            maxAge\n        });\n        // to enable read-after-write in the same request for middleware\n        reqCookies.set(cookieName, cookieValue);\n        // check if the session cookie size exceeds 4096 bytes, and if so, log a warning\n        const cookieJarSizeTest = new cookies.ResponseCookies(new Headers());\n        cookieJarSizeTest.set(cookieName, cookieValue, {\n            ...this.cookieConfig,\n            maxAge\n        });\n        if (new TextEncoder().encode(cookieJarSizeTest.toString()).length >= 4096) {\n            // if the cookie is the session cookie, log a warning with additional information about the claims and user profile.\n            if (cookieName === this.sessionCookieName) {\n                console.warn(`The ${cookieName} cookie size exceeds 4096 bytes, which may cause issues in some browsers. ` +\n                    \"Consider removing any unnecessary custom claims from the access token or the user profile. \" +\n                    \"Alternatively, you can use a stateful session implementation to store the session data in a data store.\");\n            }\n            else {\n                console.warn(`The ${cookieName} cookie size exceeds 4096 bytes, which may cause issues in some browsers. ` +\n                    \"You can use a stateful session implementation to store the session data in a data store.\");\n            }\n        }\n    }\n    getConnectionTokenSetsCookies(cookies) {\n        return cookies\n            .getAll()\n            .filter((cookie) => cookie.name.startsWith(this.connectionTokenSetsCookieName));\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1468, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/server/transaction-store.js"],"sourcesContent":["import * as cookies from \"./cookies\";\nconst TRANSACTION_COOKIE_PREFIX = \"__txn_\";\n/**\n * TransactionStore is responsible for storing the state required to successfully complete\n * an authentication transaction. The store relies on encrypted, stateless cookies to store\n * the transaction state.\n */\nexport class TransactionStore {\n    constructor({ secret, cookieOptions }) {\n        this.secret = secret;\n        this.transactionCookiePrefix =\n            cookieOptions?.prefix ?? TRANSACTION_COOKIE_PREFIX;\n        this.cookieConfig = {\n            httpOnly: true,\n            sameSite: cookieOptions?.sameSite ?? \"lax\", // required to allow the cookie to be sent on the callback request\n            secure: cookieOptions?.secure ?? false,\n            path: cookieOptions?.path ?? \"/\",\n            maxAge: 60 * 60 // 1 hour in seconds\n        };\n    }\n    /**\n     * Returns the name of the cookie used to store the transaction state.\n     * The cookie name is derived from the state parameter to prevent collisions\n     * between different transactions.\n     */\n    getTransactionCookieName(state) {\n        return `${this.transactionCookiePrefix}${state}`;\n    }\n    /**\n     * Returns the configured prefix for transaction cookies.\n     */\n    getCookiePrefix() {\n        return this.transactionCookiePrefix;\n    }\n    async save(resCookies, transactionState) {\n        const expiration = Math.floor(Date.now() / 1000 + this.cookieConfig.maxAge);\n        const jwe = await cookies.encrypt(transactionState, this.secret, expiration);\n        if (!transactionState.state) {\n            throw new Error(\"Transaction state is required\");\n        }\n        resCookies.set(this.getTransactionCookieName(transactionState.state), jwe.toString(), this.cookieConfig);\n    }\n    async get(reqCookies, state) {\n        const cookieName = this.getTransactionCookieName(state);\n        const cookieValue = reqCookies.get(cookieName)?.value;\n        if (!cookieValue) {\n            return null;\n        }\n        return cookies.decrypt(cookieValue, this.secret);\n    }\n    async delete(resCookies, state) {\n        await resCookies.delete(this.getTransactionCookieName(state));\n    }\n    /**\n     * Deletes all transaction cookies based on the configured prefix.\n     */\n    async deleteAll(reqCookies, resCookies) {\n        const txnPrefix = this.getCookiePrefix();\n        reqCookies.getAll().forEach((cookie) => {\n            if (cookie.name.startsWith(txnPrefix)) {\n                resCookies.delete(cookie.name);\n            }\n        });\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AAAA;;AACA,MAAM,4BAA4B;AAM3B,MAAM;IACT,YAAY,EAAE,MAAM,EAAE,aAAa,EAAE,CAAE;QACnC,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,uBAAuB,GACxB,eAAe,UAAU;QAC7B,IAAI,CAAC,YAAY,GAAG;YAChB,UAAU;YACV,UAAU,eAAe,YAAY;YACrC,QAAQ,eAAe,UAAU;YACjC,MAAM,eAAe,QAAQ;YAC7B,QAAQ,KAAK,GAAG,oBAAoB;QACxC;IACJ;IACA;;;;KAIC,GACD,yBAAyB,KAAK,EAAE;QAC5B,OAAO,GAAG,IAAI,CAAC,uBAAuB,GAAG,OAAO;IACpD;IACA;;KAEC,GACD,kBAAkB;QACd,OAAO,IAAI,CAAC,uBAAuB;IACvC;IACA,MAAM,KAAK,UAAU,EAAE,gBAAgB,EAAE;QACrC,MAAM,aAAa,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM;QAC1E,MAAM,MAAM,MAAM,CAAA,GAAA,uLAAA,CAAA,UAAe,AAAD,EAAE,kBAAkB,IAAI,CAAC,MAAM,EAAE;QACjE,IAAI,CAAC,iBAAiB,KAAK,EAAE;YACzB,MAAM,IAAI,MAAM;QACpB;QACA,WAAW,GAAG,CAAC,IAAI,CAAC,wBAAwB,CAAC,iBAAiB,KAAK,GAAG,IAAI,QAAQ,IAAI,IAAI,CAAC,YAAY;IAC3G;IACA,MAAM,IAAI,UAAU,EAAE,KAAK,EAAE;QACzB,MAAM,aAAa,IAAI,CAAC,wBAAwB,CAAC;QACjD,MAAM,cAAc,WAAW,GAAG,CAAC,aAAa;QAChD,IAAI,CAAC,aAAa;YACd,OAAO;QACX;QACA,OAAO,CAAA,GAAA,uLAAA,CAAA,UAAe,AAAD,EAAE,aAAa,IAAI,CAAC,MAAM;IACnD;IACA,MAAM,OAAO,UAAU,EAAE,KAAK,EAAE;QAC5B,MAAM,WAAW,MAAM,CAAC,IAAI,CAAC,wBAAwB,CAAC;IAC1D;IACA;;KAEC,GACD,MAAM,UAAU,UAAU,EAAE,UAAU,EAAE;QACpC,MAAM,YAAY,IAAI,CAAC,eAAe;QACtC,WAAW,MAAM,GAAG,OAAO,CAAC,CAAC;YACzB,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,YAAY;gBACnC,WAAW,MAAM,CAAC,OAAO,IAAI;YACjC;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1535, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/server/client.js"],"sourcesContent":["import { cookies } from \"next/headers\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { AccessTokenError, AccessTokenErrorCode, AccessTokenForConnectionError, AccessTokenForConnectionErrorCode } from \"../errors\";\nimport { AuthClient } from \"./auth-client\";\nimport { RequestCookies, ResponseCookies } from \"./cookies\";\nimport { StatefulSessionStore } from \"./session/stateful-session-store\";\nimport { StatelessSessionStore } from \"./session/stateless-session-store\";\nimport { TransactionStore } from \"./transaction-store\";\nexport class Auth0Client {\n    constructor(options = {}) {\n        // Extract and validate required options\n        const { domain, clientId, clientSecret, appBaseUrl, secret, clientAssertionSigningKey } = this.validateAndExtractRequiredOptions(options);\n        const clientAssertionSigningAlg = options.clientAssertionSigningAlg ||\n            process.env.AUTH0_CLIENT_ASSERTION_SIGNING_ALG;\n        const sessionCookieOptions = {\n            name: options.session?.cookie?.name ?? \"__session\",\n            secure: options.session?.cookie?.secure ??\n                process.env.AUTH0_COOKIE_SECURE === \"true\",\n            sameSite: options.session?.cookie?.sameSite ??\n                process.env.AUTH0_COOKIE_SAME_SITE ??\n                \"lax\",\n            path: options.session?.cookie?.path ?? process.env.AUTH0_COOKIE_PATH ?? \"/\",\n            transient: options.session?.cookie?.transient ??\n                process.env.AUTH0_COOKIE_TRANSIENT === \"true\",\n            domain: options.session?.cookie?.domain ?? process.env.AUTH0_COOKIE_DOMAIN\n        };\n        const transactionCookieOptions = {\n            prefix: options.transactionCookie?.prefix ?? \"__txn_\",\n            secure: options.transactionCookie?.secure ?? false,\n            sameSite: options.transactionCookie?.sameSite ?? \"lax\",\n            path: options.transactionCookie?.path ?? \"/\"\n        };\n        if (appBaseUrl) {\n            const { protocol } = new URL(appBaseUrl);\n            if (protocol === \"https:\") {\n                sessionCookieOptions.secure = true;\n                transactionCookieOptions.secure = true;\n            }\n        }\n        this.transactionStore = new TransactionStore({\n            ...options.session,\n            secret,\n            cookieOptions: transactionCookieOptions\n        });\n        this.sessionStore = options.sessionStore\n            ? new StatefulSessionStore({\n                ...options.session,\n                secret,\n                store: options.sessionStore,\n                cookieOptions: sessionCookieOptions\n            })\n            : new StatelessSessionStore({\n                ...options.session,\n                secret,\n                cookieOptions: sessionCookieOptions\n            });\n        this.authClient = new AuthClient({\n            transactionStore: this.transactionStore,\n            sessionStore: this.sessionStore,\n            domain,\n            clientId,\n            clientSecret,\n            clientAssertionSigningKey,\n            clientAssertionSigningAlg,\n            authorizationParameters: options.authorizationParameters,\n            pushedAuthorizationRequests: options.pushedAuthorizationRequests,\n            appBaseUrl,\n            secret,\n            signInReturnToPath: options.signInReturnToPath,\n            beforeSessionSaved: options.beforeSessionSaved,\n            onCallback: options.onCallback,\n            routes: options.routes,\n            allowInsecureRequests: options.allowInsecureRequests,\n            httpTimeout: options.httpTimeout,\n            enableTelemetry: options.enableTelemetry,\n            enableAccessTokenEndpoint: options.enableAccessTokenEndpoint\n        });\n    }\n    /**\n     * middleware mounts the SDK routes to run as a middleware function.\n     */\n    middleware(req) {\n        return this.authClient.handler.bind(this.authClient)(req);\n    }\n    /**\n     * getSession returns the session data for the current request.\n     */\n    async getSession(req) {\n        if (req) {\n            // middleware usage\n            if (req instanceof NextRequest) {\n                return this.sessionStore.get(req.cookies);\n            }\n            // pages router usage\n            return this.sessionStore.get(this.createRequestCookies(req));\n        }\n        // app router usage: Server Components, Server Actions, Route Handlers\n        return this.sessionStore.get(await cookies());\n    }\n    /**\n     * getAccessToken returns the access token.\n     *\n     * NOTE: Server Components cannot set cookies. Calling `getAccessToken()` in a Server Component will cause the access token to be refreshed, if it is expired, and the updated token set will not to be persisted.\n     * It is recommended to call `getAccessToken(req, res)` in the middleware if you need to retrieve the access token in a Server Component to ensure the updated token set is persisted.\n     */\n    async getAccessToken(arg1, arg2, arg3) {\n        const defaultOptions = {\n            refresh: false\n        };\n        let req = undefined;\n        let res = undefined;\n        let options = {};\n        // Determine which overload was called based on arguments\n        if (arg1 &&\n            (arg1 instanceof Request || typeof arg1.headers === \"object\")) {\n            // Case: getAccessToken(req, res, options?)\n            req = arg1;\n            res = arg2; // arg2 must be Response if arg1 is Request\n            // Merge provided options (arg3) with defaults\n            options = { ...defaultOptions, ...(arg3 ?? {}) };\n            if (!res) {\n                throw new TypeError(\"getAccessToken(req, res): The 'res' argument is missing. Both 'req' and 'res' must be provided together for Pages Router or middleware usage.\");\n            }\n        }\n        else {\n            // Case: getAccessToken(options?) or getAccessToken()\n            // arg1 (if present) must be options, arg2 and arg3 must be undefined.\n            if (arg2 !== undefined || arg3 !== undefined) {\n                throw new TypeError(\"getAccessToken: Invalid arguments. Valid signatures are getAccessToken(), getAccessToken(options), or getAccessToken(req, res, options).\");\n            }\n            // Merge provided options (arg1) with defaults\n            options = {\n                ...defaultOptions,\n                ...(arg1 ?? {})\n            };\n        }\n        const session = req\n            ? await this.getSession(req)\n            : await this.getSession();\n        if (!session) {\n            throw new AccessTokenError(AccessTokenErrorCode.MISSING_SESSION, \"The user does not have an active session.\");\n        }\n        const [error, tokenSet] = await this.authClient.getTokenSet(session.tokenSet, options.refresh);\n        if (error) {\n            throw error;\n        }\n        // update the session with the new token set, if necessary\n        if (tokenSet.accessToken !== session.tokenSet.accessToken ||\n            tokenSet.expiresAt !== session.tokenSet.expiresAt ||\n            tokenSet.refreshToken !== session.tokenSet.refreshToken) {\n            await this.saveToSession({\n                ...session,\n                tokenSet\n            }, req, res);\n        }\n        return {\n            token: tokenSet.accessToken,\n            scope: tokenSet.scope,\n            expiresAt: tokenSet.expiresAt\n        };\n    }\n    /**\n     * Retrieves an access token for a connection.\n     *\n     * This method attempts to obtain an access token for a specified connection.\n     * It first checks if a session exists, either from the provided request or from cookies.\n     * If no session is found, it throws a `AccessTokenForConnectionError` indicating\n     * that the user does not have an active session.\n     *\n     * @param {AccessTokenForConnectionOptions} options - Options for retrieving an access token for a connection.\n     * @param {PagesRouterRequest | NextRequest} [req] - An optional request object from which to extract session information.\n     * @param {PagesRouterResponse | NextResponse} [res] - An optional response object from which to extract session information.\n     *\n     * @throws {AccessTokenForConnectionError} If the user does not have an active session.\n     * @throws {Error} If there is an error during the token exchange process.\n     *\n     * @returns {Promise<{ token: string; expiresAt: number; scope?: string }} An object containing the access token and its expiration time.\n     */\n    async getAccessTokenForConnection(options, req, res) {\n        const session = req\n            ? await this.getSession(req)\n            : await this.getSession();\n        if (!session) {\n            throw new AccessTokenForConnectionError(AccessTokenForConnectionErrorCode.MISSING_SESSION, \"The user does not have an active session.\");\n        }\n        // Find the connection token set in the session\n        const existingTokenSet = session.connectionTokenSets?.find((tokenSet) => tokenSet.connection === options.connection);\n        const [error, retrievedTokenSet] = await this.authClient.getConnectionTokenSet(session.tokenSet, existingTokenSet, options);\n        if (error !== null) {\n            throw error;\n        }\n        // If we didnt have a corresponding connection token set in the session\n        // or if the one we have in the session does not match the one we received\n        // We want to update the store incase we retrieved a token set.\n        if (retrievedTokenSet &&\n            (!existingTokenSet ||\n                retrievedTokenSet.accessToken !== existingTokenSet.accessToken ||\n                retrievedTokenSet.expiresAt !== existingTokenSet.expiresAt ||\n                retrievedTokenSet.scope !== existingTokenSet.scope)) {\n            let tokenSets;\n            // If we already had the connection token set in the session\n            // we need to update the item in the array\n            // If not, we need to add it.\n            if (existingTokenSet) {\n                tokenSets = session.connectionTokenSets?.map((tokenSet) => tokenSet.connection === options.connection\n                    ? retrievedTokenSet\n                    : tokenSet);\n            }\n            else {\n                tokenSets = [...(session.connectionTokenSets || []), retrievedTokenSet];\n            }\n            await this.saveToSession({\n                ...session,\n                connectionTokenSets: tokenSets\n            }, req, res);\n        }\n        return {\n            token: retrievedTokenSet.accessToken,\n            scope: retrievedTokenSet.scope,\n            expiresAt: retrievedTokenSet.expiresAt\n        };\n    }\n    /**\n     * updateSession updates the session of the currently authenticated user. If the user does not have a session, an error is thrown.\n     */\n    async updateSession(reqOrSession, res, sessionData) {\n        if (!res) {\n            // app router: Server Actions, Route Handlers\n            const existingSession = await this.getSession();\n            if (!existingSession) {\n                throw new Error(\"The user is not authenticated.\");\n            }\n            const updatedSession = reqOrSession;\n            if (!updatedSession) {\n                throw new Error(\"The session data is missing.\");\n            }\n            await this.sessionStore.set(await cookies(), await cookies(), {\n                ...updatedSession,\n                internal: {\n                    ...existingSession.internal\n                }\n            });\n        }\n        else {\n            const req = reqOrSession;\n            if (!sessionData) {\n                throw new Error(\"The session data is missing.\");\n            }\n            if (req instanceof NextRequest && res instanceof NextResponse) {\n                // middleware usage\n                const existingSession = await this.getSession(req);\n                if (!existingSession) {\n                    throw new Error(\"The user is not authenticated.\");\n                }\n                await this.sessionStore.set(req.cookies, res.cookies, {\n                    ...sessionData,\n                    internal: {\n                        ...existingSession.internal\n                    }\n                });\n            }\n            else {\n                // pages router usage\n                const existingSession = await this.getSession(req);\n                if (!existingSession) {\n                    throw new Error(\"The user is not authenticated.\");\n                }\n                const resHeaders = new Headers();\n                const resCookies = new ResponseCookies(resHeaders);\n                const updatedSession = sessionData;\n                const reqCookies = this.createRequestCookies(req);\n                const pagesRouterRes = res;\n                await this.sessionStore.set(reqCookies, resCookies, {\n                    ...updatedSession,\n                    internal: {\n                        ...existingSession.internal\n                    }\n                });\n                for (const [key, value] of resHeaders.entries()) {\n                    pagesRouterRes.setHeader(key, value);\n                }\n            }\n        }\n    }\n    createRequestCookies(req) {\n        const headers = new Headers();\n        for (const key in req.headers) {\n            if (Array.isArray(req.headers[key])) {\n                for (const value of req.headers[key]) {\n                    headers.append(key, value);\n                }\n            }\n            else {\n                headers.append(key, req.headers[key] ?? \"\");\n            }\n        }\n        return new RequestCookies(headers);\n    }\n    async startInteractiveLogin(options) {\n        return this.authClient.startInteractiveLogin(options);\n    }\n    async saveToSession(data, req, res) {\n        if (req && res) {\n            if (req instanceof NextRequest && res instanceof NextResponse) {\n                // middleware usage\n                await this.sessionStore.set(req.cookies, res.cookies, data);\n            }\n            else {\n                // pages router usage\n                const resHeaders = new Headers();\n                const resCookies = new ResponseCookies(resHeaders);\n                const pagesRouterRes = res;\n                await this.sessionStore.set(this.createRequestCookies(req), resCookies, data);\n                for (const [key, value] of resHeaders.entries()) {\n                    pagesRouterRes.setHeader(key, value);\n                }\n            }\n        }\n        else {\n            // app router usage: Server Components, Server Actions, Route Handlers\n            try {\n                await this.sessionStore.set(await cookies(), await cookies(), data);\n            }\n            catch (e) {\n                if (process.env.NODE_ENV === \"development\") {\n                    console.warn(\"Failed to persist the updated token set. `getAccessToken()` was likely called from a Server Component which cannot set cookies.\");\n                }\n            }\n        }\n    }\n    /**\n     * Validates and extracts required configuration options.\n     * @param options The client options\n     * @returns The validated required options\n     * @throws ConfigurationError if any required option is missing\n     */\n    validateAndExtractRequiredOptions(options) {\n        // Base required options that are always needed\n        const requiredOptions = {\n            domain: options.domain ?? process.env.AUTH0_DOMAIN,\n            clientId: options.clientId ?? process.env.AUTH0_CLIENT_ID,\n            appBaseUrl: options.appBaseUrl ?? process.env.APP_BASE_URL,\n            secret: options.secret ?? process.env.AUTH0_SECRET\n        };\n        // Check client authentication options - either clientSecret OR clientAssertionSigningKey must be provided\n        const clientSecret = options.clientSecret ?? process.env.AUTH0_CLIENT_SECRET;\n        const clientAssertionSigningKey = options.clientAssertionSigningKey ??\n            process.env.AUTH0_CLIENT_ASSERTION_SIGNING_KEY;\n        const hasClientAuthentication = !!(clientSecret || clientAssertionSigningKey);\n        const missing = Object.entries(requiredOptions)\n            .filter(([, value]) => !value)\n            .map(([key]) => key);\n        // Add client authentication error if neither option is provided\n        if (!hasClientAuthentication) {\n            missing.push(\"clientAuthentication\");\n        }\n        if (missing.length) {\n            // Map of option keys to their exact environment variable names\n            const envVarNames = {\n                domain: \"AUTH0_DOMAIN\",\n                clientId: \"AUTH0_CLIENT_ID\",\n                appBaseUrl: \"APP_BASE_URL\",\n                secret: \"AUTH0_SECRET\"\n            };\n            // Standard intro message explaining the issue\n            let errorMessage = \"WARNING: Not all required options where provided when creating an instance of Auth0Client. Ensure to provide all missing options, either by passing it to the Auth0Client constructor, or by setting the corresponding environment variable.\\n\";\n            // Add specific details for each missing option\n            missing.forEach((key) => {\n                if (key === \"clientAuthentication\") {\n                    errorMessage += `Missing: clientAuthentication: Set either AUTH0_CLIENT_SECRET env var or AUTH0_CLIENT_ASSERTION_SIGNING_KEY env var, or pass clientSecret or clientAssertionSigningKey in options\\n`;\n                }\n                else if (envVarNames[key]) {\n                    errorMessage += `Missing: ${key}: Set ${envVarNames[key]} env var or pass ${key} in options\\n`;\n                }\n                else {\n                    errorMessage += `Missing: ${key}\\n`;\n                }\n            });\n            console.error(errorMessage.trim());\n        }\n        // Prepare the result object with all validated options\n        const result = {\n            ...requiredOptions,\n            clientSecret,\n            clientAssertionSigningKey\n        };\n        // Type-safe assignment after validation\n        return result;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1910, "column": 0}, "map": {"version":3,"sources":["file:///home/mgrumadas/projects/match4paws/node_modules/%40auth0/nextjs-auth0/dist/server/index.js"],"sourcesContent":["export { Auth0Client } from \"./client\";\nexport { AuthClient } from \"./auth-client\";\nexport { TransactionStore } from \"./transaction-store\";\nexport { AbstractSessionStore } from \"./session/abstract-session-store\";\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA","ignoreList":[0],"debugId":null}}]
}