module.exports = {

"[project]/node_modules/@auth0/nextjs-auth0/dist/errors/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AccessTokenError": (()=>AccessTokenError),
    "AccessTokenErrorCode": (()=>AccessTokenErrorCode),
    "AccessTokenForConnectionError": (()=>AccessTokenForConnectionError),
    "AccessTokenForConnectionErrorCode": (()=>AccessTokenForConnectionErrorCode),
    "AuthorizationCodeGrantError": (()=>AuthorizationCodeGrantError),
    "AuthorizationError": (()=>AuthorizationError),
    "BackchannelLogoutError": (()=>BackchannelLogoutError),
    "DiscoveryError": (()=>DiscoveryError),
    "InvalidStateError": (()=>InvalidStateError),
    "MissingStateError": (()=>MissingStateError),
    "OAuth2Error": (()=>OAuth2Error),
    "SdkError": (()=>SdkError)
});
class SdkError extends Error {
}
class OAuth2Error extends SdkError {
    constructor({ code, message }){
        super(message ?? "An error occured while interacting with the authorization server.");
        this.name = "OAuth2Error";
        this.code = code;
    }
}
class DiscoveryError extends SdkError {
    constructor(message){
        super(message ?? "Discovery failed for the OpenID Connect configuration.");
        this.code = "discovery_error";
        this.name = "DiscoveryError";
    }
}
class MissingStateError extends SdkError {
    constructor(message){
        super(message ?? "The state parameter is missing.");
        this.code = "missing_state";
        this.name = "MissingStateError";
    }
}
class InvalidStateError extends SdkError {
    constructor(message){
        super(message ?? "The state parameter is invalid.");
        this.code = "invalid_state";
        this.name = "InvalidStateError";
    }
}
class AuthorizationError extends SdkError {
    constructor({ cause, message }){
        super(message ?? "An error occured during the authorization flow.");
        this.code = "authorization_error";
        this.cause = cause;
        this.name = "AuthorizationError";
    }
}
class AuthorizationCodeGrantError extends SdkError {
    constructor({ cause, message }){
        super(message ?? "An error occured while trying to exchange the authorization code.");
        this.code = "authorization_code_grant_error";
        this.cause = cause;
        this.name = "AuthorizationCodeGrantError";
    }
}
class BackchannelLogoutError extends SdkError {
    constructor(message){
        super(message ?? "An error occured while completing the backchannel logout request.");
        this.code = "backchannel_logout_error";
        this.name = "BackchannelLogoutError";
    }
}
var AccessTokenErrorCode;
(function(AccessTokenErrorCode) {
    AccessTokenErrorCode["MISSING_SESSION"] = "missing_session";
    AccessTokenErrorCode["MISSING_REFRESH_TOKEN"] = "missing_refresh_token";
    AccessTokenErrorCode["FAILED_TO_REFRESH_TOKEN"] = "failed_to_refresh_token";
})(AccessTokenErrorCode || (AccessTokenErrorCode = {}));
class AccessTokenError extends SdkError {
    constructor(code, message){
        super(message);
        this.name = "AccessTokenError";
        this.code = code;
    }
}
var AccessTokenForConnectionErrorCode;
(function(AccessTokenForConnectionErrorCode) {
    /**
     * The session is missing.
     */ AccessTokenForConnectionErrorCode["MISSING_SESSION"] = "missing_session";
    /**
     * The refresh token is missing.
     */ AccessTokenForConnectionErrorCode["MISSING_REFRESH_TOKEN"] = "missing_refresh_token";
    /**
     * Failed to exchange the refresh token.
     */ AccessTokenForConnectionErrorCode["FAILED_TO_EXCHANGE"] = "failed_to_exchange_refresh_token";
})(AccessTokenForConnectionErrorCode || (AccessTokenForConnectionErrorCode = {}));
class AccessTokenForConnectionError extends SdkError {
    /**
     * Constructs a new `AccessTokenForConnectionError` instance.
     *
     * @param code - The error code.
     * @param message - The error message.
     * @param cause - The OAuth2 cause of the error.
     */ constructor(code, message, cause){
        super(message);
        this.name = "AccessTokenForConnectionError";
        this.code = code;
        this.cause = cause;
    }
}
}}),
"[project]/node_modules/@auth0/nextjs-auth0/package.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"name\":\"@auth0/nextjs-auth0\",\"version\":\"4.6.1\",\"description\":\"Auth0 Next.js SDK\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/auth0/nextjs-auth0.git\"},\"keywords\":[\"auth0\",\"next.js\",\"react\",\"oidc\",\"authentication\",\"vercel\"],\"author\":\"Auth0 (https://auth0.com)\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/auth0/nextjs-auth0/issues\"},\"homepage\":\"https://github.com/auth0/nextjs-auth0#readme\",\"devDependencies\":{\"msw\":\"^2.7.5\",\"@eslint/js\":\"^9.20.0\",\"@ianvs/prettier-plugin-sort-imports\":\"^4.3.1\",\"@playwright/test\":\"^1.48.2\",\"@stylistic/eslint-plugin-ts\":\"^3.1.0\",\"@testing-library/react\":\"^16.3.0\",\"@types/node\":\"^22.8.6\",\"@types/react\":\"*\",\"@types/react-dom\":\"*\",\"@vitest/coverage-v8\":\"2.1.9\",\"eslint\":\"^9.20.0\",\"eslint-config-prettier\":\"^10.0.1\",\"eslint-plugin-prettier\":\"^5.2.3\",\"eslint-plugin-react\":\"^7.37.4\",\"globals\":\"^15.14.0\",\"jsdom\":\"^26.1.0\",\"next\":\"15.2.3\",\"prettier\":\"^3.3.3\",\"typedoc\":\"^0.28.4\",\"typescript\":\"^5.6.3\",\"typescript-eslint\":\"^8.23.0\",\"vite\":\"^5.4.11\",\"vitest\":\"^2.1.4\"},\"peerDependencies\":{\"next\":\"^14.2.25 || ^15.2.3\",\"react\":\"^18.0.0 || ^19.0.0 || ^19.0.0-0\",\"react-dom\":\"^18.0.0 || ^19.0.0 || ^19.0.0-0\"},\"exports\":{\".\":{\"import\":\"./dist/client/index.js\"},\"./server\":{\"import\":\"./dist/server/index.js\"},\"./errors\":{\"import\":\"./dist/errors/index.js\"},\"./types\":{\"import\":\"./dist/types/index.d.ts\"},\"./testing\":{\"import\":\"./dist/testing/index.js\"}},\"dependencies\":{\"@edge-runtime/cookies\":\"^5.0.1\",\"@panva/hkdf\":\"^1.2.1\",\"jose\":\"^5.9.6\",\"oauth4webapi\":\"^3.1.2\",\"swr\":\"^2.2.5\"},\"publishConfig\":{\"access\":\"public\"},\"typesVersions\":{\"*\":{\"testing\":[\"./dist/testing/index.d.ts\"],\"types\":[\"./dist/types/index.d.ts\"],\"server\":[\"./dist/server/index.d.ts\"],\"errors\":[\"./dist/errors/index.d.ts\"],\"*\":[\"./dist/client/*\",\"./dist/client/index.d.ts\"]}},\"files\":[\"dist\"],\"scripts\":{\"build\":\"tsc\",\"build:watch\":\"tsc -w\",\"test:unit\":\"vitest\",\"test:coverage\":\"vitest run --coverage\",\"test:e2e\":\"playwright test\",\"install:examples\":\"pnpm install --filter ./examples/with-next-intl --shamefully-hoist && pnpm install --filter ./examples/with-shadcn --shamefully-hoist\",\"docs\":\"typedoc\",\"lint\":\"tsc --noEmit && eslint --fix ./src\"}}"));}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/utils/pathUtils.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ensureNoLeadingSlash": (()=>ensureNoLeadingSlash),
    "ensureTrailingSlash": (()=>ensureTrailingSlash),
    "removeTrailingSlash": (()=>removeTrailingSlash)
});
function ensureTrailingSlash(value) {
    return value && !value.endsWith("/") ? `${value}/` : value;
}
function ensureNoLeadingSlash(value) {
    return value && value.startsWith("/") ? value.substring(1, value.length) : value;
}
const removeTrailingSlash = (path)=>path.endsWith("/") ? path.slice(0, -1) : path;
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/utils/url-helpers.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "toSafeRedirect": (()=>toSafeRedirect)
});
function toSafeRedirect(dangerousRedirect, safeBaseUrl) {
    let url;
    try {
        url = new URL(dangerousRedirect, safeBaseUrl);
    } catch (e) {
        return undefined;
    }
    if (url.origin === safeBaseUrl.origin) {
        return url.toString();
    }
    return undefined;
}
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/server/cookies.js [app-rsc] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "addCacheControlHeadersForSession": (()=>addCacheControlHeadersForSession),
    "decrypt": (()=>decrypt),
    "deleteChunkedCookie": (()=>deleteChunkedCookie),
    "encrypt": (()=>encrypt),
    "getChunkedCookie": (()=>getChunkedCookie),
    "setChunkedCookie": (()=>setChunkedCookie),
    "sign": (()=>sign),
    "verifySigned": (()=>verifySigned)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$edge$2d$runtime$2f$cookies$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@edge-runtime/cookies/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$panva$2f$hkdf$2f$dist$2f$node$2f$esm$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@panva/hkdf/dist/node/esm/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwt$2f$encrypt$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jose/dist/node/esm/jwt/encrypt.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwt$2f$decrypt$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jose/dist/node/esm/jwt/decrypt.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$util$2f$base64url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__base64url$3e$__ = __turbopack_context__.i("[project]/node_modules/jose/dist/node/esm/util/base64url.js [app-rsc] (ecmascript) <export * as base64url>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jws$2f$flattened$2f$verify$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jose/dist/node/esm/jws/flattened/verify.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jws$2f$flattened$2f$sign$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jose/dist/node/esm/jws/flattened/sign.js [app-rsc] (ecmascript)");
;
;
;
const ENC = "A256GCM";
const ALG = "dir";
const DIGEST = "sha256";
const BYTE_LENGTH = 32;
const ENCRYPTION_INFO = "JWE CEK";
async function encrypt(payload, secret, expiration, additionalHeaders) {
    const encryptionSecret = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$panva$2f$hkdf$2f$dist$2f$node$2f$esm$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"])(DIGEST, secret, "", ENCRYPTION_INFO, BYTE_LENGTH);
    const encryptedCookie = await new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwt$2f$encrypt$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EncryptJWT"](payload).setProtectedHeader({
        enc: ENC,
        alg: ALG,
        ...additionalHeaders
    }).setExpirationTime(expiration).encrypt(encryptionSecret);
    return encryptedCookie.toString();
}
async function decrypt(cookieValue, secret, options) {
    const encryptionSecret = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$panva$2f$hkdf$2f$dist$2f$node$2f$esm$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"])(DIGEST, secret, "", ENCRYPTION_INFO, BYTE_LENGTH);
    const cookie = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwt$2f$decrypt$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jwtDecrypt"])(cookieValue, encryptionSecret, {
        ...options,
        ...{
            clockTolerance: 15
        }
    });
    return cookie;
}
/**
 * Derive a signing key from a given secret.
 * This method is used solely to migrate signed, legacy cookies to the new encrypted cookie format (v4+).
 */ const signingSecret = (secret)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$panva$2f$hkdf$2f$dist$2f$node$2f$esm$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"])("sha256", secret, "", "JWS Cookie Signing", BYTE_LENGTH);
async function verifySigned(k, v, secret) {
    if (!v) {
        return undefined;
    }
    const [value, signature] = v.split(".");
    const flattenedJWS = {
        protected: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$util$2f$base64url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__base64url$3e$__["base64url"].encode(JSON.stringify({
            alg: "HS256",
            b64: false,
            crit: [
                "b64"
            ]
        })),
        payload: `${k}=${value}`,
        signature
    };
    const key = await signingSecret(secret);
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jws$2f$flattened$2f$verify$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["flattenedVerify"])(flattenedJWS, key, {
            algorithms: [
                "HS256"
            ]
        });
        return value;
    } catch (e) {
        return undefined;
    }
}
async function sign(name, value, secret) {
    const key = await signingSecret(secret);
    const { signature } = await new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jws$2f$flattened$2f$sign$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FlattenedSign"](new TextEncoder().encode(`${name}=${value}`)).setProtectedHeader({
        alg: "HS256",
        b64: false,
        crit: [
            "b64"
        ]
    }).sign(key);
    return `${value}.${signature}`;
}
;
;
// Chunked cookies Configuration
const MAX_CHUNK_SIZE = 3500; // Slightly under 4KB
const CHUNK_PREFIX = "__";
const CHUNK_INDEX_REGEX = new RegExp(`${CHUNK_PREFIX}(\\d+)$`);
const LEGACY_CHUNK_INDEX_REGEX = /\.(\d+)$/;
/**
 * Retrieves the index of a cookie based on its name.
 * Supports current format `{name}__{index}` and legacy format `{name}.{index}`.
 *
 * @param name - The name of the cookie.
 * @returns The index of the cookie. Returns undefined if no index is found.
 */ const getChunkedCookieIndex = (name, isLegacyCookie)=>{
    const match = isLegacyCookie ? LEGACY_CHUNK_INDEX_REGEX.exec(name) : CHUNK_INDEX_REGEX.exec(name);
    if (!match) {
        return undefined;
    }
    return parseInt(match[1], 10);
};
/**
 * Retrieves all cookies from the request that have names starting with a specific prefix.
 *
 * @param reqCookies - The cookies from the request.
 * @param name - The base name of the cookies to retrieve.
 * @returns An array of cookies that have names starting with the specified prefix.
 */ const getAllChunkedCookies = (reqCookies, name, isLegacyCookie)=>{
    const chunkedCookieRegex = new RegExp(isLegacyCookie ? `^${name}${LEGACY_CHUNK_INDEX_REGEX.source}$` : `^${name}${CHUNK_PREFIX}\\d+$`);
    return reqCookies.getAll().filter((cookie)=>chunkedCookieRegex.test(cookie.name));
};
function setChunkedCookie(name, value, options, reqCookies, resCookies) {
    const { transient, ...restOptions } = options;
    const finalOptions = {
        ...restOptions
    };
    if (transient) {
        delete finalOptions.maxAge;
    }
    const valueBytes = new TextEncoder().encode(value).length;
    // If value fits in a single cookie, set it directly
    if (valueBytes <= MAX_CHUNK_SIZE) {
        resCookies.set(name, value, finalOptions);
        // to enable read-after-write in the same request for middleware
        reqCookies.set(name, value);
        // When we are writing a non-chunked cookie, we should remove the chunked cookies
        getAllChunkedCookies(reqCookies, name).forEach((cookieChunk)=>{
            resCookies.delete(cookieChunk.name);
            reqCookies.delete(cookieChunk.name);
        });
        return;
    }
    // Split value into chunks
    let position = 0;
    let chunkIndex = 0;
    while(position < value.length){
        const chunk = value.slice(position, position + MAX_CHUNK_SIZE);
        const chunkName = `${name}${CHUNK_PREFIX}${chunkIndex}`;
        resCookies.set(chunkName, chunk, finalOptions);
        // to enable read-after-write in the same request for middleware
        reqCookies.set(chunkName, chunk);
        position += MAX_CHUNK_SIZE;
        chunkIndex++;
    }
    // clear unused chunks
    const chunks = getAllChunkedCookies(reqCookies, name);
    const chunksToRemove = chunks.length - chunkIndex;
    if (chunksToRemove > 0) {
        for(let i = 0; i < chunksToRemove; i++){
            const chunkIndexToRemove = chunkIndex + i;
            const chunkName = `${name}${CHUNK_PREFIX}${chunkIndexToRemove}`;
            resCookies.delete(chunkName);
            reqCookies.delete(chunkName);
        }
    }
    // When we have written chunked cookies, we should remove the non-chunked cookie
    resCookies.delete(name);
    reqCookies.delete(name);
}
function getChunkedCookie(name, reqCookies, isLegacyCookie) {
    // Check if regular cookie exists
    const cookie = reqCookies.get(name);
    if (cookie?.value) {
        // If the base cookie exists, return its value (handles non-chunked case)
        return cookie.value;
    }
    const chunks = getAllChunkedCookies(reqCookies, name, isLegacyCookie).sort(// Extract index from cookie name and sort numerically
    (first, second)=>{
        return getChunkedCookieIndex(first.name, isLegacyCookie) - getChunkedCookieIndex(second.name, isLegacyCookie);
    });
    if (chunks.length === 0) {
        return undefined;
    }
    // Validate sequence integrity - check for missing chunks
    const highestIndex = getChunkedCookieIndex(chunks[chunks.length - 1].name, isLegacyCookie);
    if (chunks.length !== highestIndex + 1) {
        console.warn(`Incomplete chunked cookie '${name}': Found ${chunks.length} chunks, expected ${highestIndex + 1}`);
        return undefined;
    }
    // Combine all chunks
    return chunks.map((c)=>c.value).join("");
}
function deleteChunkedCookie(name, reqCookies, resCookies, isLegacyCookie) {
    // Delete main cookie
    resCookies.delete(name);
    getAllChunkedCookies(reqCookies, name, isLegacyCookie).forEach((cookie)=>{
        resCookies.delete(cookie.name); // Delete each filtered cookie
    });
}
function addCacheControlHeadersForSession(res) {
    res.headers.set("Cache-Control", "private, no-cache, no-store, must-revalidate, max-age=0");
    res.headers.set("Pragma", "no-cache");
    res.headers.set("Expires", "0");
}
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/server/cookies.js [app-rsc] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$edge$2d$runtime$2f$cookies$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@edge-runtime/cookies/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/cookies.js [app-rsc] (ecmascript) <locals>");
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/server/user.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "filterClaims": (()=>filterClaims)
});
const DEFAULT_ALLOWED_CLAIMS = [
    "sub",
    "name",
    "nickname",
    "given_name",
    "family_name",
    "picture",
    "email",
    "email_verified",
    "org_id"
];
function filterClaims(claims) {
    return Object.keys(claims).reduce((acc, key)=>{
        if (DEFAULT_ALLOWED_CLAIMS.includes(key)) {
            acc[key] = claims[key];
        }
        return acc;
    }, {});
}
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/server/auth-client.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AuthClient": (()=>AuthClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwks$2f$remote$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jose/dist/node/esm/jwks/remote.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwt$2f$verify$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jose/dist/node/esm/jwt/verify.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$key$2f$import$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jose/dist/node/esm/key/import.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/oauth4webapi/build/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$package$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/package.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/errors/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$utils$2f$pathUtils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/pathUtils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$utils$2f$url$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/url-helpers.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/cookies.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/cookies.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$user$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/user.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
// params passed to the /authorize endpoint that cannot be overwritten
const INTERNAL_AUTHORIZE_PARAMS = [
    "client_id",
    "redirect_uri",
    "response_type",
    "code_challenge",
    "code_challenge_method",
    "state",
    "nonce"
];
const DEFAULT_SCOPES = [
    "openid",
    "profile",
    "email",
    "offline_access"
].join(" ");
/**
 * A constant representing the grant type for federated connection access token exchange.
 *
 * This grant type is used in OAuth token exchange scenarios where a federated connection
 * access token is required. It is specific to Auth0's implementation and follows the
 * "urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token" format.
 */ const GRANT_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN = "urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token";
/**
 * Constant representing the subject type for a refresh token.
 * This is used in OAuth 2.0 token exchange to specify that the token being exchanged is a refresh token.
 *
 * @see {@link https://tools.ietf.org/html/rfc8693#section-3.1 RFC 8693 Section 3.1}
 */ const SUBJECT_TYPE_REFRESH_TOKEN = "urn:ietf:params:oauth:token-type:refresh_token";
/**
 * A constant representing the token type for federated connection access tokens.
 * This is used to specify the type of token being requested from Auth0.
 *
 * @constant
 * @type {string}
 */ const REQUESTED_TOKEN_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN = "http://auth0.com/oauth/token-type/federated-connection-access-token";
function createRouteUrl(url, base) {
    return new URL((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$utils$2f$pathUtils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ensureNoLeadingSlash"])(url), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$utils$2f$pathUtils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ensureTrailingSlash"])(base));
}
class AuthClient {
    constructor(options){
        // dependencies
        this.fetch = options.fetch || fetch;
        this.jwksCache = options.jwksCache || {};
        this.allowInsecureRequests = options.allowInsecureRequests ?? false;
        this.httpOptions = ()=>{
            const headers = new Headers();
            const enableTelemetry = options.enableTelemetry ?? true;
            const timeout = options.httpTimeout ?? 5000;
            if (enableTelemetry) {
                const name = "nextjs-auth0";
                const version = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$package$2e$json__$28$json$29$__["default"].version;
                headers.set("User-Agent", `${name}/${version}`);
                headers.set("Auth0-Client", encodeBase64(JSON.stringify({
                    name,
                    version
                })));
            }
            return {
                signal: AbortSignal.timeout(timeout),
                headers
            };
        };
        if (this.allowInsecureRequests && ("TURBOPACK compile-time value", "development") === "production") {
            "TURBOPACK unreachable";
        }
        // stores
        this.transactionStore = options.transactionStore;
        this.sessionStore = options.sessionStore;
        // authorization server
        this.domain = options.domain;
        this.clientMetadata = {
            client_id: options.clientId
        };
        this.clientSecret = options.clientSecret;
        this.authorizationParameters = options.authorizationParameters || {
            scope: DEFAULT_SCOPES
        };
        this.pushedAuthorizationRequests = options.pushedAuthorizationRequests ?? false;
        this.clientAssertionSigningKey = options.clientAssertionSigningKey;
        this.clientAssertionSigningAlg = options.clientAssertionSigningAlg || "RS256";
        if (!this.authorizationParameters.scope) {
            this.authorizationParameters.scope = DEFAULT_SCOPES;
        }
        const scope = this.authorizationParameters.scope.split(" ").map((s)=>s.trim());
        if (!scope.includes("openid")) {
            throw new Error("The 'openid' scope must be included in the set of scopes. See https://auth0.com/docs");
        }
        // application
        this.appBaseUrl = options.appBaseUrl;
        this.signInReturnToPath = options.signInReturnToPath || "/";
        // hooks
        this.beforeSessionSaved = options.beforeSessionSaved;
        this.onCallback = options.onCallback || this.defaultOnCallback;
        // routes
        this.routes = {
            login: "/auth/login",
            logout: "/auth/logout",
            callback: "/auth/callback",
            backChannelLogout: "/auth/backchannel-logout",
            profile: process.env.NEXT_PUBLIC_PROFILE_ROUTE || "/auth/profile",
            accessToken: process.env.NEXT_PUBLIC_ACCESS_TOKEN_ROUTE || "/auth/access-token",
            ...options.routes
        };
        this.enableAccessTokenEndpoint = options.enableAccessTokenEndpoint ?? true;
    }
    async handler(req) {
        const { pathname } = req.nextUrl;
        const sanitizedPathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$utils$2f$pathUtils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["removeTrailingSlash"])(pathname);
        const method = req.method;
        if (method === "GET" && sanitizedPathname === this.routes.login) {
            return this.handleLogin(req);
        } else if (method === "GET" && sanitizedPathname === this.routes.logout) {
            return this.handleLogout(req);
        } else if (method === "GET" && sanitizedPathname === this.routes.callback) {
            return this.handleCallback(req);
        } else if (method === "GET" && sanitizedPathname === this.routes.profile) {
            return this.handleProfile(req);
        } else if (method === "GET" && sanitizedPathname === this.routes.accessToken && this.enableAccessTokenEndpoint) {
            return this.handleAccessToken(req);
        } else if (method === "POST" && sanitizedPathname === this.routes.backChannelLogout) {
            return this.handleBackChannelLogout(req);
        } else {
            // no auth handler found, simply touch the sessions
            // TODO: this should only happen if rolling sessions are enabled. Also, we should
            // try to avoid reading from the DB (for stateful sessions) on every request if possible.
            const res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"].next();
            const session = await this.sessionStore.get(req.cookies);
            if (session) {
                // we pass the existing session (containing an `createdAt` timestamp) to the set method
                // which will update the cookie's `maxAge` property based on the `createdAt` time
                await this.sessionStore.set(req.cookies, res.cookies, {
                    ...session
                });
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addCacheControlHeadersForSession"])(res);
            }
            return res;
        }
    }
    async startInteractiveLogin(options = {}) {
        const redirectUri = createRouteUrl(this.routes.callback, this.appBaseUrl); // must be registed with the authorization server
        let returnTo = this.signInReturnToPath;
        // Validate returnTo parameter
        if (options.returnTo) {
            const safeBaseUrl = new URL(this.authorizationParameters.redirect_uri || this.appBaseUrl);
            const sanitizedReturnTo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$utils$2f$url$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toSafeRedirect"])(options.returnTo, safeBaseUrl);
            if (sanitizedReturnTo) {
                returnTo = sanitizedReturnTo;
            }
        }
        // Generate PKCE challenges
        const codeChallengeMethod = "S256";
        const codeVerifier = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["generateRandomCodeVerifier"])();
        const codeChallenge = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["calculatePKCECodeChallenge"])(codeVerifier);
        const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["generateRandomState"])();
        const nonce = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["generateRandomNonce"])();
        // Construct base authorization parameters
        const authorizationParams = new URLSearchParams();
        authorizationParams.set("client_id", this.clientMetadata.client_id);
        authorizationParams.set("redirect_uri", redirectUri.toString());
        authorizationParams.set("response_type", "code");
        authorizationParams.set("code_challenge", codeChallenge);
        authorizationParams.set("code_challenge_method", codeChallengeMethod);
        authorizationParams.set("state", state);
        authorizationParams.set("nonce", nonce);
        const mergedAuthorizationParams = {
            // any custom params to forward to /authorize defined as configuration
            ...this.authorizationParameters,
            // custom parameters passed in via the query params to ensure only the confidential client can set them
            ...options.authorizationParameters
        };
        Object.entries(mergedAuthorizationParams).forEach(([key, val])=>{
            if (!INTERNAL_AUTHORIZE_PARAMS.includes(key) && val != null) {
                authorizationParams.set(key, String(val));
            }
        });
        // Prepare transaction state
        const transactionState = {
            nonce,
            maxAge: this.authorizationParameters.max_age,
            codeVerifier,
            responseType: "code",
            state,
            returnTo
        };
        // Generate authorization URL with PAR handling
        const [error, authorizationUrl] = await this.authorizationUrl(authorizationParams);
        if (error) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"]("An error occured while trying to initiate the login request.", {
                status: 500
            });
        }
        // Set response and save transaction
        const res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"].redirect(authorizationUrl.toString());
        await this.transactionStore.save(res.cookies, transactionState);
        return res;
    }
    async handleLogin(req) {
        const searchParams = Object.fromEntries(req.nextUrl.searchParams.entries());
        const options = {
            // SECURITY CRITICAL: Only forward query params when PAR is disabled
            authorizationParameters: !this.pushedAuthorizationRequests ? searchParams : {},
            returnTo: searchParams.returnTo
        };
        return this.startInteractiveLogin(options);
    }
    async handleLogout(req) {
        const session = await this.sessionStore.get(req.cookies);
        const [discoveryError, authorizationServerMetadata] = await this.discoverAuthorizationServerMetadata();
        if (discoveryError) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"]("An error occured while trying to initiate the logout request.", {
                status: 500
            });
        }
        const returnTo = req.nextUrl.searchParams.get("returnTo") || this.appBaseUrl;
        if (!authorizationServerMetadata.end_session_endpoint) {
            // the Auth0 client does not have RP-initiated logout enabled, redirect to the `/v2/logout` endpoint
            console.warn("The Auth0 client does not have RP-initiated logout enabled, the user will be redirected to the `/v2/logout` endpoint instead. Learn how to enable it here: https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0#enable-endpoint-discovery");
            const url = new URL("/v2/logout", this.issuer);
            url.searchParams.set("returnTo", returnTo);
            url.searchParams.set("client_id", this.clientMetadata.client_id);
            const res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"].redirect(url);
            await this.sessionStore.delete(req.cookies, res.cookies);
            // Clear any orphaned transaction cookies
            await this.transactionStore.deleteAll(req.cookies, res.cookies);
            return res;
        }
        const url = new URL(authorizationServerMetadata.end_session_endpoint);
        url.searchParams.set("client_id", this.clientMetadata.client_id);
        url.searchParams.set("post_logout_redirect_uri", returnTo);
        if (session?.internal.sid) {
            url.searchParams.set("logout_hint", session.internal.sid);
        }
        if (session?.tokenSet.idToken) {
            url.searchParams.set("id_token_hint", session?.tokenSet.idToken);
        }
        const res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"].redirect(url);
        await this.sessionStore.delete(req.cookies, res.cookies);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addCacheControlHeadersForSession"])(res);
        // Clear any orphaned transaction cookies
        await this.transactionStore.deleteAll(req.cookies, res.cookies);
        return res;
    }
    async handleCallback(req) {
        const state = req.nextUrl.searchParams.get("state");
        if (!state) {
            return this.onCallback(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MissingStateError"](), {}, null);
        }
        const transactionStateCookie = await this.transactionStore.get(req.cookies, state);
        if (!transactionStateCookie) {
            return this.onCallback(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InvalidStateError"](), {}, null);
        }
        const transactionState = transactionStateCookie.payload;
        const onCallbackCtx = {
            returnTo: transactionState.returnTo
        };
        const [discoveryError, authorizationServerMetadata] = await this.discoverAuthorizationServerMetadata();
        if (discoveryError) {
            return this.onCallback(discoveryError, onCallbackCtx, null);
        }
        let codeGrantParams;
        try {
            codeGrantParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["validateAuthResponse"])(authorizationServerMetadata, this.clientMetadata, req.nextUrl.searchParams, transactionState.state);
        } catch (e) {
            return this.onCallback(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AuthorizationError"]({
                cause: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["OAuth2Error"]({
                    code: e.error,
                    message: e.error_description
                })
            }), onCallbackCtx, null);
        }
        const redirectUri = createRouteUrl(this.routes.callback, this.appBaseUrl); // must be registed with the authorization server
        const codeGrantResponse = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["authorizationCodeGrantRequest"])(authorizationServerMetadata, this.clientMetadata, await this.getClientAuth(), codeGrantParams, redirectUri.toString(), transactionState.codeVerifier, {
            ...this.httpOptions(),
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["customFetch"]]: this.fetch,
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["allowInsecureRequests"]]: this.allowInsecureRequests
        });
        let oidcRes;
        try {
            oidcRes = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["processAuthorizationCodeResponse"])(authorizationServerMetadata, this.clientMetadata, codeGrantResponse, {
                expectedNonce: transactionState.nonce,
                maxAge: transactionState.maxAge,
                requireIdToken: true
            });
        } catch (e) {
            return this.onCallback(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AuthorizationCodeGrantError"]({
                cause: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["OAuth2Error"]({
                    code: e.error,
                    message: e.error_description
                })
            }), onCallbackCtx, null);
        }
        const idTokenClaims = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getValidatedIdTokenClaims"])(oidcRes);
        let session = {
            user: idTokenClaims,
            tokenSet: {
                accessToken: oidcRes.access_token,
                idToken: oidcRes.id_token,
                scope: oidcRes.scope,
                refreshToken: oidcRes.refresh_token,
                expiresAt: Math.floor(Date.now() / 1000) + Number(oidcRes.expires_in)
            },
            internal: {
                sid: idTokenClaims.sid,
                createdAt: Math.floor(Date.now() / 1000)
            }
        };
        const res = await this.onCallback(null, onCallbackCtx, session);
        if (this.beforeSessionSaved) {
            const updatedSession = await this.beforeSessionSaved(session, oidcRes.id_token ?? null);
            session = {
                ...updatedSession,
                internal: session.internal
            };
        } else {
            session.user = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$user$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["filterClaims"])(idTokenClaims);
        }
        await this.sessionStore.set(req.cookies, res.cookies, session, true);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addCacheControlHeadersForSession"])(res);
        await this.transactionStore.delete(res.cookies, state);
        return res;
    }
    async handleProfile(req) {
        const session = await this.sessionStore.get(req.cookies);
        if (!session) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"](null, {
                status: 401
            });
        }
        const res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"].json(session?.user);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addCacheControlHeadersForSession"])(res);
        return res;
    }
    async handleAccessToken(req) {
        const session = await this.sessionStore.get(req.cookies);
        if (!session) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: {
                    message: "The user does not have an active session.",
                    code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenErrorCode"].MISSING_SESSION
                }
            }, {
                status: 401
            });
        }
        const [error, updatedTokenSet] = await this.getTokenSet(session.tokenSet);
        if (error) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: {
                    message: error.message,
                    code: error.code
                }
            }, {
                status: 401
            });
        }
        const res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"].json({
            token: updatedTokenSet.accessToken,
            scope: updatedTokenSet.scope,
            expires_at: updatedTokenSet.expiresAt
        });
        if (updatedTokenSet.accessToken !== session.tokenSet.accessToken || updatedTokenSet.refreshToken !== session.tokenSet.refreshToken || updatedTokenSet.expiresAt !== session.tokenSet.expiresAt) {
            await this.sessionStore.set(req.cookies, res.cookies, {
                ...session,
                tokenSet: updatedTokenSet
            });
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addCacheControlHeadersForSession"])(res);
        }
        return res;
    }
    async handleBackChannelLogout(req) {
        if (!this.sessionStore.store) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"]("A session data store is not configured.", {
                status: 500
            });
        }
        if (!this.sessionStore.store.deleteByLogoutToken) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"]("Back-channel logout is not supported by the session data store.", {
                status: 500
            });
        }
        const body = new URLSearchParams(await req.text());
        const logoutToken = body.get("logout_token");
        if (!logoutToken) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"]("Missing `logout_token` in the request body.", {
                status: 400
            });
        }
        const [error, logoutTokenClaims] = await this.verifyLogoutToken(logoutToken);
        if (error) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"](error.message, {
                status: 400
            });
        }
        await this.sessionStore.store.deleteByLogoutToken(logoutTokenClaims);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"](null, {
            status: 204
        });
    }
    /**
     * getTokenSet returns a valid token set. If the access token has expired, it will attempt to
     * refresh it using the refresh token, if available.
     */ async getTokenSet(tokenSet, forceRefresh) {
        // the access token has expired but we do not have a refresh token
        if (!tokenSet.refreshToken && tokenSet.expiresAt <= Date.now() / 1000) {
            return [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenError"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenErrorCode"].MISSING_REFRESH_TOKEN, "The access token has expired and a refresh token was not provided. The user needs to re-authenticate."),
                null
            ];
        }
        if (tokenSet.refreshToken) {
            // either the access token has expired or we are forcing a refresh
            if (forceRefresh || tokenSet.expiresAt <= Date.now() / 1000) {
                const [discoveryError, authorizationServerMetadata] = await this.discoverAuthorizationServerMetadata();
                if (discoveryError) {
                    console.error(discoveryError);
                    return [
                        discoveryError,
                        null
                    ];
                }
                const refreshTokenRes = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["refreshTokenGrantRequest"])(authorizationServerMetadata, this.clientMetadata, await this.getClientAuth(), tokenSet.refreshToken, {
                    ...this.httpOptions(),
                    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["customFetch"]]: this.fetch,
                    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["allowInsecureRequests"]]: this.allowInsecureRequests
                });
                let oauthRes;
                try {
                    oauthRes = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["processRefreshTokenResponse"])(authorizationServerMetadata, this.clientMetadata, refreshTokenRes);
                } catch (e) {
                    console.error(e);
                    return [
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenError"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenErrorCode"].FAILED_TO_REFRESH_TOKEN, "The access token has expired and there was an error while trying to refresh it. Check the server logs for more information."),
                        null
                    ];
                }
                const accessTokenExpiresAt = Math.floor(Date.now() / 1000) + Number(oauthRes.expires_in);
                const updatedTokenSet = {
                    ...tokenSet,
                    accessToken: oauthRes.access_token,
                    idToken: oauthRes.id_token,
                    expiresAt: accessTokenExpiresAt
                };
                if (oauthRes.refresh_token) {
                    // refresh token rotation is enabled, persist the new refresh token from the response
                    updatedTokenSet.refreshToken = oauthRes.refresh_token;
                } else {
                    // we did not get a refresh token back, keep the current long-lived refresh token around
                    updatedTokenSet.refreshToken = tokenSet.refreshToken;
                }
                return [
                    null,
                    updatedTokenSet
                ];
            }
        }
        return [
            null,
            tokenSet
        ];
    }
    async discoverAuthorizationServerMetadata() {
        if (this.authorizationServerMetadata) {
            return [
                null,
                this.authorizationServerMetadata
            ];
        }
        const issuer = new URL(this.issuer);
        try {
            const authorizationServerMetadata = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["discoveryRequest"])(issuer, {
                ...this.httpOptions(),
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["customFetch"]]: this.fetch,
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["allowInsecureRequests"]]: this.allowInsecureRequests
            }).then((response)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["processDiscoveryResponse"])(issuer, response));
            this.authorizationServerMetadata = authorizationServerMetadata;
            return [
                null,
                authorizationServerMetadata
            ];
        } catch (e) {
            console.error(`An error occured while performing the discovery request. Please make sure the AUTH0_DOMAIN environment variable is correctly configured  the format must be 'example.us.auth0.com'. issuer=${issuer.toString()}, error:`, e);
            return [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DiscoveryError"]("Discovery failed for the OpenID Connect configuration."),
                null
            ];
        }
    }
    async defaultOnCallback(error, ctx) {
        if (error) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"](error.message, {
                status: 500
            });
        }
        const res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"].redirect(createRouteUrl(ctx.returnTo || "/", this.appBaseUrl));
        return res;
    }
    async verifyLogoutToken(logoutToken) {
        const [discoveryError, authorizationServerMetadata] = await this.discoverAuthorizationServerMetadata();
        if (discoveryError) {
            return [
                discoveryError,
                null
            ];
        }
        // only `RS256` is supported for logout tokens
        const ID_TOKEN_SIGNING_ALG = "RS256";
        const keyInput = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwks$2f$remote$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createRemoteJWKSet"])(new URL(authorizationServerMetadata.jwks_uri), {
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwks$2f$remote$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jwksCache"]]: this.jwksCache
        });
        const { payload } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwt$2f$verify$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jwtVerify"])(logoutToken, keyInput, {
            issuer: authorizationServerMetadata.issuer,
            audience: this.clientMetadata.client_id,
            algorithms: [
                ID_TOKEN_SIGNING_ALG
            ],
            requiredClaims: [
                "iat"
            ]
        });
        if (!("sid" in payload) && !("sub" in payload)) {
            return [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BackchannelLogoutError"]('either "sid" or "sub" (or both) claims must be present'),
                null
            ];
        }
        if ("sid" in payload && typeof payload.sid !== "string") {
            return [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BackchannelLogoutError"]('"sid" claim must be a string'),
                null
            ];
        }
        if ("sub" in payload && typeof payload.sub !== "string") {
            return [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BackchannelLogoutError"]('"sub" claim must be a string'),
                null
            ];
        }
        if ("nonce" in payload) {
            return [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BackchannelLogoutError"]('"nonce" claim is prohibited'),
                null
            ];
        }
        if (!("events" in payload)) {
            return [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BackchannelLogoutError"]('"events" claim is missing'),
                null
            ];
        }
        if (typeof payload.events !== "object" || payload.events === null) {
            return [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BackchannelLogoutError"]('"events" claim must be an object'),
                null
            ];
        }
        if (!("http://schemas.openid.net/event/backchannel-logout" in payload.events)) {
            return [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BackchannelLogoutError"]('"http://schemas.openid.net/event/backchannel-logout" member is missing in the "events" claim'),
                null
            ];
        }
        if (typeof payload.events["http://schemas.openid.net/event/backchannel-logout"] !== "object") {
            return [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BackchannelLogoutError"]('"http://schemas.openid.net/event/backchannel-logout" member in the "events" claim must be an object'),
                null
            ];
        }
        return [
            null,
            {
                sid: payload.sid,
                sub: payload.sub
            }
        ];
    }
    async authorizationUrl(params) {
        const [discoveryError, authorizationServerMetadata] = await this.discoverAuthorizationServerMetadata();
        if (discoveryError) {
            return [
                discoveryError,
                null
            ];
        }
        if (this.pushedAuthorizationRequests && !authorizationServerMetadata.pushed_authorization_request_endpoint) {
            console.error("The Auth0 tenant does not have pushed authorization requests enabled. Learn how to enable it here: https://auth0.com/docs/get-started/applications/configure-par");
            return [
                new Error("The authorization server does not support pushed authorization requests."),
                null
            ];
        }
        const authorizationUrl = new URL(authorizationServerMetadata.authorization_endpoint);
        if (this.pushedAuthorizationRequests) {
            // push the request params to the authorization server
            const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["pushedAuthorizationRequest"])(authorizationServerMetadata, this.clientMetadata, await this.getClientAuth(), params, {
                ...this.httpOptions(),
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["customFetch"]]: this.fetch,
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["allowInsecureRequests"]]: this.allowInsecureRequests
            });
            let parRes;
            try {
                parRes = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["processPushedAuthorizationResponse"])(authorizationServerMetadata, this.clientMetadata, response);
            } catch (e) {
                return [
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AuthorizationError"]({
                        cause: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["OAuth2Error"]({
                            code: e.error,
                            message: e.error_description
                        }),
                        message: "An error occured while pushing the authorization request."
                    }),
                    null
                ];
            }
            authorizationUrl.searchParams.set("request_uri", parRes.request_uri);
            authorizationUrl.searchParams.set("client_id", this.clientMetadata.client_id);
            return [
                null,
                authorizationUrl
            ];
        }
        // append the query parameters to the authorization URL for the normal flow
        authorizationUrl.search = params.toString();
        return [
            null,
            authorizationUrl
        ];
    }
    async getClientAuth() {
        if (!this.clientSecret && !this.clientAssertionSigningKey) {
            throw new Error("The client secret or client assertion signing key must be provided.");
        }
        let clientPrivateKey = this.clientAssertionSigningKey;
        if (clientPrivateKey && !(clientPrivateKey instanceof CryptoKey)) {
            clientPrivateKey = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$key$2f$import$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["importPKCS8"])(clientPrivateKey, this.clientAssertionSigningAlg);
        }
        return clientPrivateKey ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PrivateKeyJwt"])(clientPrivateKey) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ClientSecretPost"])(this.clientSecret);
    }
    get issuer() {
        return this.domain.startsWith("http://") || this.domain.startsWith("https://") ? this.domain : `https://${this.domain}`;
    }
    /**
     * Exchanges a refresh token for an access token for a connection.
     *
     * This method performs a token exchange using the provided refresh token and connection details.
     * It first checks if the refresh token is present in the `tokenSet`. If not, it returns an error.
     * Then, it constructs the necessary parameters for the token exchange request and performs
     * the request to the authorization server's token endpoint.
     *
     * @returns {Promise<[AccessTokenForConnectionError, null] | [null, ConnectionTokenSet]>} A promise that resolves to a tuple.
     *          The first element is either an `AccessTokenForConnectionError` if an error occurred, or `null` if the request was successful.
     *          The second element is either `null` if an error occurred, or a `ConnectionTokenSet` object
     *          containing the access token, expiration time, and scope if the request was successful.
     *
     * @throws {AccessTokenForConnectionError} If the refresh token is missing or if there is an error during the token exchange process.
     */ async getConnectionTokenSet(tokenSet, connectionTokenSet, options) {
        // If we do not have a refresh token
        // and we do not have a connection token set in the cache or the one we have is expired,
        // there is noting to retrieve and we return an error.
        if (!tokenSet.refreshToken && (!connectionTokenSet || connectionTokenSet.expiresAt <= Date.now() / 1000)) {
            return [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenForConnectionError"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenForConnectionErrorCode"].MISSING_REFRESH_TOKEN, "A refresh token was not present, Connection Access Token requires a refresh token. The user needs to re-authenticate."),
                null
            ];
        }
        // If we do have a refresh token,
        // and we do not have a connection token set in the cache or the one we have is expired,
        // we need to exchange the refresh token for a connection access token.
        if (tokenSet.refreshToken && (!connectionTokenSet || connectionTokenSet.expiresAt <= Date.now() / 1000)) {
            const params = new URLSearchParams();
            params.append("connection", options.connection);
            params.append("subject_token_type", SUBJECT_TYPE_REFRESH_TOKEN);
            params.append("subject_token", tokenSet.refreshToken);
            params.append("requested_token_type", REQUESTED_TOKEN_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN);
            if (options.login_hint) {
                params.append("login_hint", options.login_hint);
            }
            const [discoveryError, authorizationServerMetadata] = await this.discoverAuthorizationServerMetadata();
            if (discoveryError) {
                console.error(discoveryError);
                return [
                    discoveryError,
                    null
                ];
            }
            const httpResponse = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["genericTokenEndpointRequest"])(authorizationServerMetadata, this.clientMetadata, await this.getClientAuth(), GRANT_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN, params, {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["customFetch"]]: this.fetch,
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["allowInsecureRequests"]]: this.allowInsecureRequests
            });
            let tokenEndpointResponse;
            try {
                tokenEndpointResponse = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oauth4webapi$2f$build$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["processGenericTokenEndpointResponse"])(authorizationServerMetadata, this.clientMetadata, httpResponse);
            } catch (err) {
                console.error(err);
                return [
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenForConnectionError"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenForConnectionErrorCode"].FAILED_TO_EXCHANGE, "There was an error trying to exchange the refresh token for a connection access token. Check the server logs for more information.", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["OAuth2Error"]({
                        code: err.error,
                        message: err.error_description
                    })),
                    null
                ];
            }
            return [
                null,
                {
                    accessToken: tokenEndpointResponse.access_token,
                    expiresAt: Math.floor(Date.now() / 1000) + Number(tokenEndpointResponse.expires_in),
                    scope: tokenEndpointResponse.scope,
                    connection: options.connection
                }
            ];
        }
        return [
            null,
            connectionTokenSet
        ];
    }
}
const encodeBase64 = (input)=>{
    const unencoded = new TextEncoder().encode(input);
    const CHUNK_SIZE = 0x8000;
    const arr = [];
    for(let i = 0; i < unencoded.length; i += CHUNK_SIZE){
        arr.push(// @ts-expect-error Argument of type 'Uint8Array' is not assignable to parameter of type 'number[]'.
        String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
    }
    return btoa(arr.join(""));
};
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/server/session/abstract-session-store.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AbstractSessionStore": (()=>AbstractSessionStore)
});
const SESSION_COOKIE_NAME = "__session";
class AbstractSessionStore {
    constructor({ secret, rolling = true, absoluteDuration = 60 * 60 * 24 * 3, inactivityDuration = 60 * 60 * 24 * 1, store, cookieOptions }){
        this.secret = secret;
        this.rolling = rolling;
        this.absoluteDuration = absoluteDuration;
        this.inactivityDuration = inactivityDuration;
        this.store = store;
        this.sessionCookieName = cookieOptions?.name ?? SESSION_COOKIE_NAME;
        this.cookieConfig = {
            httpOnly: true,
            sameSite: cookieOptions?.sameSite ?? "lax",
            secure: cookieOptions?.secure ?? false,
            path: cookieOptions?.path ?? "/",
            domain: cookieOptions?.domain,
            transient: cookieOptions?.transient
        };
    }
    /**
     * epoch returns the time since unix epoch in seconds.
     */ epoch() {
        return Date.now() / 1000 | 0;
    }
    /**
     * calculateMaxAge calculates the max age of the session based on createdAt and the rolling and absolute durations.
     */ calculateMaxAge(createdAt) {
        if (!this.rolling) {
            return this.absoluteDuration;
        }
        const updatedAt = this.epoch();
        const expiresAt = Math.min(updatedAt + this.inactivityDuration, createdAt + this.absoluteDuration);
        const maxAge = expiresAt - this.epoch();
        return maxAge > 0 ? maxAge : 0;
    }
}
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/server/session/normalize-session.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "LEGACY_COOKIE_NAME": (()=>LEGACY_COOKIE_NAME),
    "LegacySession": (()=>LegacySession),
    "normalizeStatefulSession": (()=>normalizeStatefulSession),
    "normalizeStatelessSession": (()=>normalizeStatelessSession)
});
const LEGACY_COOKIE_NAME = "appSession";
class LegacySession {
    constructor(user){
        this.user = user;
    }
}
function normalizeStatelessSession(sessionCookie) {
    // if the session cookie has an `iat` claim in the protected header, it's a legacy cookie
    // otherwise, it's the new session cookie format and no transformation is needed
    if (sessionCookie.protectedHeader.iat) {
        const legacySession = sessionCookie;
        return convertFromLegacy(legacySession.protectedHeader, legacySession.payload);
    }
    return sessionCookie.payload;
}
function normalizeStatefulSession(sessionData) {
    if (sessionData.header?.iat) {
        const legacySession = sessionData;
        return convertFromLegacy(legacySession.header, legacySession.data);
    }
    return sessionData;
}
function convertFromLegacy(header, session) {
    const userClaims = session.user;
    return {
        user: userClaims,
        tokenSet: {
            idToken: session.idToken ?? undefined,
            accessToken: session.accessToken ?? undefined,
            scope: session.accessTokenScope,
            refreshToken: session.refreshToken,
            expiresAt: session.accessTokenExpiresAt
        },
        internal: {
            sid: userClaims.sid,
            createdAt: header.iat
        }
    };
}
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/server/session/stateful-session-store.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "StatefulSessionStore": (()=>StatefulSessionStore)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/cookies.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/cookies.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$abstract$2d$session$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/session/abstract-session-store.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$normalize$2d$session$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/session/normalize-session.js [app-rsc] (ecmascript)");
;
;
;
const generateId = ()=>{
    const bytes = new Uint8Array(16);
    crypto.getRandomValues(bytes);
    return Array.from(bytes).map((b)=>b.toString(16).padStart(2, "0")).join("");
};
class StatefulSessionStore extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$abstract$2d$session$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AbstractSessionStore"] {
    constructor({ secret, store, rolling, absoluteDuration, inactivityDuration, cookieOptions }){
        super({
            secret,
            rolling,
            absoluteDuration,
            inactivityDuration,
            cookieOptions
        });
        this.store = store;
    }
    async get(reqCookies) {
        const cookie = reqCookies.get(this.sessionCookieName) || reqCookies.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$normalize$2d$session$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["LEGACY_COOKIE_NAME"]);
        if (!cookie || !cookie.value) {
            return null;
        }
        // we attempt to extract the session ID by decrypting the cookie value (assuming it's a JWE, v4+) first
        // if that fails, we attempt to verify the cookie value as a signed cookie (legacy, v3-)
        // if both fail, we return null
        // this ensures that v3 sessions are respected and can be transparently rolled over to v4+ sessions
        let sessionId = null;
        try {
            const { payload: sessionCookie } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decrypt"])(cookie.value, this.secret);
            sessionId = sessionCookie.id;
        } catch (e) {
            // the session cookie could not be decrypted, try to verify if it's a legacy session
            if (e.code === "ERR_JWE_INVALID") {
                const legacySessionId = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["verifySigned"])(cookie.name, cookie.value, this.secret);
                if (!legacySessionId) {
                    return null;
                }
                sessionId = legacySessionId;
            }
        }
        if (!sessionId) {
            return null;
        }
        const session = await this.store.get(sessionId);
        if (!session) {
            return null;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$normalize$2d$session$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeStatefulSession"])(session);
    }
    async set(reqCookies, resCookies, session, isNew = false) {
        // check if a session already exists. If so, maintain the existing session ID
        let sessionId = null;
        const cookieValue = reqCookies.get(this.sessionCookieName)?.value;
        if (cookieValue) {
            const { payload: sessionCookie } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decrypt"])(cookieValue, this.secret);
            sessionId = sessionCookie.id;
        }
        // if this is a new session created by a new login we need to remove the old session
        // from the store and regenerate the session ID to prevent session fixation.
        if (sessionId && isNew) {
            await this.store.delete(sessionId);
            sessionId = generateId();
        }
        if (!sessionId) {
            sessionId = generateId();
        }
        const maxAge = this.calculateMaxAge(session.internal.createdAt);
        const expiration = Date.now() / 1000 + maxAge;
        const jwe = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encrypt"])({
            id: sessionId
        }, this.secret, expiration);
        resCookies.set(this.sessionCookieName, jwe.toString(), {
            ...this.cookieConfig,
            maxAge
        });
        await this.store.set(sessionId, session);
        // to enable read-after-write in the same request for middleware
        reqCookies.set(this.sessionCookieName, jwe.toString());
        // Any existing v3 cookie can also be deleted once we have set a v4 cookie.
        // In stateful sessions, we do not have to worry about chunking.
        if (this.sessionCookieName !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$normalize$2d$session$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["LEGACY_COOKIE_NAME"] && reqCookies.has(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$normalize$2d$session$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["LEGACY_COOKIE_NAME"])) {
            resCookies.delete(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$normalize$2d$session$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["LEGACY_COOKIE_NAME"]);
        }
    }
    async delete(reqCookies, resCookies) {
        const cookieValue = reqCookies.get(this.sessionCookieName)?.value;
        await resCookies.delete(this.sessionCookieName);
        if (!cookieValue) {
            return;
        }
        const { payload: session } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decrypt"])(cookieValue, this.secret);
        await this.store.delete(session.id);
    }
}
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/server/session/stateless-session-store.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "StatelessSessionStore": (()=>StatelessSessionStore)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/cookies.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/cookies.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$edge$2d$runtime$2f$cookies$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@edge-runtime/cookies/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$abstract$2d$session$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/session/abstract-session-store.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$normalize$2d$session$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/session/normalize-session.js [app-rsc] (ecmascript)");
;
;
;
class StatelessSessionStore extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$abstract$2d$session$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AbstractSessionStore"] {
    constructor({ secret, rolling, absoluteDuration, inactivityDuration, cookieOptions }){
        super({
            secret,
            rolling,
            absoluteDuration,
            inactivityDuration,
            cookieOptions
        });
        this.connectionTokenSetsCookieName = "__FC";
    }
    async get(reqCookies) {
        const cookieValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getChunkedCookie"])(this.sessionCookieName, reqCookies) ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getChunkedCookie"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$normalize$2d$session$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["LEGACY_COOKIE_NAME"], reqCookies, true);
        if (!cookieValue) {
            return null;
        }
        const originalSession = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decrypt"])(cookieValue, this.secret);
        const normalizedStatelessSession = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$normalize$2d$session$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeStatelessSession"])(originalSession);
        // As connection access tokens are stored in seperate cookies,
        // we need to get all cookies and only use those that are prefixed with `this.connectionTokenSetsCookieName`
        const connectionTokenSets = await Promise.all(this.getConnectionTokenSetsCookies(reqCookies).map((cookie)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decrypt"])(cookie.value, this.secret)));
        return {
            ...normalizedStatelessSession,
            // Ensure that when there are no connection token sets, we omit the property.
            ...connectionTokenSets.length ? {
                connectionTokenSets: connectionTokenSets.map((tokenSet)=>tokenSet.payload)
            } : {}
        };
    }
    /**
     * save adds the encrypted session cookie as a `Set-Cookie` header.
     */ async set(reqCookies, resCookies, session) {
        const { connectionTokenSets, ...originalSession } = session;
        const maxAge = this.calculateMaxAge(session.internal.createdAt);
        const expiration = Math.floor(Date.now() / 1000) + maxAge;
        const jwe = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encrypt"])(originalSession, this.secret, expiration);
        const cookieValue = jwe.toString();
        const options = {
            ...this.cookieConfig,
            maxAge
        };
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setChunkedCookie"])(this.sessionCookieName, cookieValue, options, reqCookies, resCookies);
        // Store connection access tokens, each in its own cookie
        if (connectionTokenSets?.length) {
            await Promise.all(connectionTokenSets.map((connectionTokenSet, index)=>this.storeInCookie(reqCookies, resCookies, connectionTokenSet, `${this.connectionTokenSetsCookieName}_${index}`, maxAge)));
        }
        // Any existing v3 cookie can be deleted as soon as we have set a v4 cookie.
        // In stateless sessions, we do have to ensure we delete all chunks.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["deleteChunkedCookie"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$normalize$2d$session$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["LEGACY_COOKIE_NAME"], reqCookies, resCookies, true);
    }
    async delete(reqCookies, resCookies) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["deleteChunkedCookie"])(this.sessionCookieName, reqCookies, resCookies);
        this.getConnectionTokenSetsCookies(reqCookies).forEach((cookie)=>resCookies.delete(cookie.name));
    }
    async storeInCookie(reqCookies, resCookies, session, cookieName, maxAge) {
        const expiration = Math.floor(Date.now() / 1000 + maxAge);
        const jwe = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encrypt"])(session, this.secret, expiration);
        const cookieValue = jwe.toString();
        resCookies.set(cookieName, jwe.toString(), {
            ...this.cookieConfig,
            maxAge
        });
        // to enable read-after-write in the same request for middleware
        reqCookies.set(cookieName, cookieValue);
        // check if the session cookie size exceeds 4096 bytes, and if so, log a warning
        const cookieJarSizeTest = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$edge$2d$runtime$2f$cookies$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ResponseCookies"](new Headers());
        cookieJarSizeTest.set(cookieName, cookieValue, {
            ...this.cookieConfig,
            maxAge
        });
        if (new TextEncoder().encode(cookieJarSizeTest.toString()).length >= 4096) {
            // if the cookie is the session cookie, log a warning with additional information about the claims and user profile.
            if (cookieName === this.sessionCookieName) {
                console.warn(`The ${cookieName} cookie size exceeds 4096 bytes, which may cause issues in some browsers. ` + "Consider removing any unnecessary custom claims from the access token or the user profile. " + "Alternatively, you can use a stateful session implementation to store the session data in a data store.");
            } else {
                console.warn(`The ${cookieName} cookie size exceeds 4096 bytes, which may cause issues in some browsers. ` + "You can use a stateful session implementation to store the session data in a data store.");
            }
        }
    }
    getConnectionTokenSetsCookies(cookies) {
        return cookies.getAll().filter((cookie)=>cookie.name.startsWith(this.connectionTokenSetsCookieName));
    }
}
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/server/transaction-store.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "TransactionStore": (()=>TransactionStore)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/cookies.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/cookies.js [app-rsc] (ecmascript) <locals>");
;
const TRANSACTION_COOKIE_PREFIX = "__txn_";
class TransactionStore {
    constructor({ secret, cookieOptions }){
        this.secret = secret;
        this.transactionCookiePrefix = cookieOptions?.prefix ?? TRANSACTION_COOKIE_PREFIX;
        this.cookieConfig = {
            httpOnly: true,
            sameSite: cookieOptions?.sameSite ?? "lax",
            secure: cookieOptions?.secure ?? false,
            path: cookieOptions?.path ?? "/",
            maxAge: 60 * 60 // 1 hour in seconds
        };
    }
    /**
     * Returns the name of the cookie used to store the transaction state.
     * The cookie name is derived from the state parameter to prevent collisions
     * between different transactions.
     */ getTransactionCookieName(state) {
        return `${this.transactionCookiePrefix}${state}`;
    }
    /**
     * Returns the configured prefix for transaction cookies.
     */ getCookiePrefix() {
        return this.transactionCookiePrefix;
    }
    async save(resCookies, transactionState) {
        const expiration = Math.floor(Date.now() / 1000 + this.cookieConfig.maxAge);
        const jwe = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encrypt"])(transactionState, this.secret, expiration);
        if (!transactionState.state) {
            throw new Error("Transaction state is required");
        }
        resCookies.set(this.getTransactionCookieName(transactionState.state), jwe.toString(), this.cookieConfig);
    }
    async get(reqCookies, state) {
        const cookieName = this.getTransactionCookieName(state);
        const cookieValue = reqCookies.get(cookieName)?.value;
        if (!cookieValue) {
            return null;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decrypt"])(cookieValue, this.secret);
    }
    async delete(resCookies, state) {
        await resCookies.delete(this.getTransactionCookieName(state));
    }
    /**
     * Deletes all transaction cookies based on the configured prefix.
     */ async deleteAll(reqCookies, resCookies) {
        const txnPrefix = this.getCookiePrefix();
        reqCookies.getAll().forEach((cookie)=>{
            if (cookie.name.startsWith(txnPrefix)) {
                resCookies.delete(cookie.name);
            }
        });
    }
}
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/server/client.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Auth0Client": (()=>Auth0Client)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/headers.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/errors/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$auth$2d$client$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/auth-client.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/cookies.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$edge$2d$runtime$2f$cookies$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@edge-runtime/cookies/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$stateful$2d$session$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/session/stateful-session-store.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$stateless$2d$session$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/session/stateless-session-store.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$transaction$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/transaction-store.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
class Auth0Client {
    constructor(options = {}){
        // Extract and validate required options
        const { domain, clientId, clientSecret, appBaseUrl, secret, clientAssertionSigningKey } = this.validateAndExtractRequiredOptions(options);
        const clientAssertionSigningAlg = options.clientAssertionSigningAlg || process.env.AUTH0_CLIENT_ASSERTION_SIGNING_ALG;
        const sessionCookieOptions = {
            name: options.session?.cookie?.name ?? "__session",
            secure: options.session?.cookie?.secure ?? process.env.AUTH0_COOKIE_SECURE === "true",
            sameSite: options.session?.cookie?.sameSite ?? process.env.AUTH0_COOKIE_SAME_SITE ?? "lax",
            path: options.session?.cookie?.path ?? process.env.AUTH0_COOKIE_PATH ?? "/",
            transient: options.session?.cookie?.transient ?? process.env.AUTH0_COOKIE_TRANSIENT === "true",
            domain: options.session?.cookie?.domain ?? process.env.AUTH0_COOKIE_DOMAIN
        };
        const transactionCookieOptions = {
            prefix: options.transactionCookie?.prefix ?? "__txn_",
            secure: options.transactionCookie?.secure ?? false,
            sameSite: options.transactionCookie?.sameSite ?? "lax",
            path: options.transactionCookie?.path ?? "/"
        };
        if (appBaseUrl) {
            const { protocol } = new URL(appBaseUrl);
            if (protocol === "https:") {
                sessionCookieOptions.secure = true;
                transactionCookieOptions.secure = true;
            }
        }
        this.transactionStore = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$transaction$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["TransactionStore"]({
            ...options.session,
            secret,
            cookieOptions: transactionCookieOptions
        });
        this.sessionStore = options.sessionStore ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$stateful$2d$session$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StatefulSessionStore"]({
            ...options.session,
            secret,
            store: options.sessionStore,
            cookieOptions: sessionCookieOptions
        }) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$stateless$2d$session$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StatelessSessionStore"]({
            ...options.session,
            secret,
            cookieOptions: sessionCookieOptions
        });
        this.authClient = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$auth$2d$client$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AuthClient"]({
            transactionStore: this.transactionStore,
            sessionStore: this.sessionStore,
            domain,
            clientId,
            clientSecret,
            clientAssertionSigningKey,
            clientAssertionSigningAlg,
            authorizationParameters: options.authorizationParameters,
            pushedAuthorizationRequests: options.pushedAuthorizationRequests,
            appBaseUrl,
            secret,
            signInReturnToPath: options.signInReturnToPath,
            beforeSessionSaved: options.beforeSessionSaved,
            onCallback: options.onCallback,
            routes: options.routes,
            allowInsecureRequests: options.allowInsecureRequests,
            httpTimeout: options.httpTimeout,
            enableTelemetry: options.enableTelemetry,
            enableAccessTokenEndpoint: options.enableAccessTokenEndpoint
        });
    }
    /**
     * middleware mounts the SDK routes to run as a middleware function.
     */ middleware(req) {
        return this.authClient.handler.bind(this.authClient)(req);
    }
    /**
     * getSession returns the session data for the current request.
     */ async getSession(req) {
        if (req) {
            // middleware usage
            if (req instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextRequest"]) {
                return this.sessionStore.get(req.cookies);
            }
            // pages router usage
            return this.sessionStore.get(this.createRequestCookies(req));
        }
        // app router usage: Server Components, Server Actions, Route Handlers
        return this.sessionStore.get(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cookies"])());
    }
    /**
     * getAccessToken returns the access token.
     *
     * NOTE: Server Components cannot set cookies. Calling `getAccessToken()` in a Server Component will cause the access token to be refreshed, if it is expired, and the updated token set will not to be persisted.
     * It is recommended to call `getAccessToken(req, res)` in the middleware if you need to retrieve the access token in a Server Component to ensure the updated token set is persisted.
     */ async getAccessToken(arg1, arg2, arg3) {
        const defaultOptions = {
            refresh: false
        };
        let req = undefined;
        let res = undefined;
        let options = {};
        // Determine which overload was called based on arguments
        if (arg1 && (arg1 instanceof Request || typeof arg1.headers === "object")) {
            // Case: getAccessToken(req, res, options?)
            req = arg1;
            res = arg2; // arg2 must be Response if arg1 is Request
            // Merge provided options (arg3) with defaults
            options = {
                ...defaultOptions,
                ...arg3 ?? {}
            };
            if (!res) {
                throw new TypeError("getAccessToken(req, res): The 'res' argument is missing. Both 'req' and 'res' must be provided together for Pages Router or middleware usage.");
            }
        } else {
            // Case: getAccessToken(options?) or getAccessToken()
            // arg1 (if present) must be options, arg2 and arg3 must be undefined.
            if (arg2 !== undefined || arg3 !== undefined) {
                throw new TypeError("getAccessToken: Invalid arguments. Valid signatures are getAccessToken(), getAccessToken(options), or getAccessToken(req, res, options).");
            }
            // Merge provided options (arg1) with defaults
            options = {
                ...defaultOptions,
                ...arg1 ?? {}
            };
        }
        const session = req ? await this.getSession(req) : await this.getSession();
        if (!session) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenError"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenErrorCode"].MISSING_SESSION, "The user does not have an active session.");
        }
        const [error, tokenSet] = await this.authClient.getTokenSet(session.tokenSet, options.refresh);
        if (error) {
            throw error;
        }
        // update the session with the new token set, if necessary
        if (tokenSet.accessToken !== session.tokenSet.accessToken || tokenSet.expiresAt !== session.tokenSet.expiresAt || tokenSet.refreshToken !== session.tokenSet.refreshToken) {
            await this.saveToSession({
                ...session,
                tokenSet
            }, req, res);
        }
        return {
            token: tokenSet.accessToken,
            scope: tokenSet.scope,
            expiresAt: tokenSet.expiresAt
        };
    }
    /**
     * Retrieves an access token for a connection.
     *
     * This method attempts to obtain an access token for a specified connection.
     * It first checks if a session exists, either from the provided request or from cookies.
     * If no session is found, it throws a `AccessTokenForConnectionError` indicating
     * that the user does not have an active session.
     *
     * @param {AccessTokenForConnectionOptions} options - Options for retrieving an access token for a connection.
     * @param {PagesRouterRequest | NextRequest} [req] - An optional request object from which to extract session information.
     * @param {PagesRouterResponse | NextResponse} [res] - An optional response object from which to extract session information.
     *
     * @throws {AccessTokenForConnectionError} If the user does not have an active session.
     * @throws {Error} If there is an error during the token exchange process.
     *
     * @returns {Promise<{ token: string; expiresAt: number; scope?: string }} An object containing the access token and its expiration time.
     */ async getAccessTokenForConnection(options, req, res) {
        const session = req ? await this.getSession(req) : await this.getSession();
        if (!session) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenForConnectionError"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$errors$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AccessTokenForConnectionErrorCode"].MISSING_SESSION, "The user does not have an active session.");
        }
        // Find the connection token set in the session
        const existingTokenSet = session.connectionTokenSets?.find((tokenSet)=>tokenSet.connection === options.connection);
        const [error, retrievedTokenSet] = await this.authClient.getConnectionTokenSet(session.tokenSet, existingTokenSet, options);
        if (error !== null) {
            throw error;
        }
        // If we didnt have a corresponding connection token set in the session
        // or if the one we have in the session does not match the one we received
        // We want to update the store incase we retrieved a token set.
        if (retrievedTokenSet && (!existingTokenSet || retrievedTokenSet.accessToken !== existingTokenSet.accessToken || retrievedTokenSet.expiresAt !== existingTokenSet.expiresAt || retrievedTokenSet.scope !== existingTokenSet.scope)) {
            let tokenSets;
            // If we already had the connection token set in the session
            // we need to update the item in the array
            // If not, we need to add it.
            if (existingTokenSet) {
                tokenSets = session.connectionTokenSets?.map((tokenSet)=>tokenSet.connection === options.connection ? retrievedTokenSet : tokenSet);
            } else {
                tokenSets = [
                    ...session.connectionTokenSets || [],
                    retrievedTokenSet
                ];
            }
            await this.saveToSession({
                ...session,
                connectionTokenSets: tokenSets
            }, req, res);
        }
        return {
            token: retrievedTokenSet.accessToken,
            scope: retrievedTokenSet.scope,
            expiresAt: retrievedTokenSet.expiresAt
        };
    }
    /**
     * updateSession updates the session of the currently authenticated user. If the user does not have a session, an error is thrown.
     */ async updateSession(reqOrSession, res, sessionData) {
        if (!res) {
            // app router: Server Actions, Route Handlers
            const existingSession = await this.getSession();
            if (!existingSession) {
                throw new Error("The user is not authenticated.");
            }
            const updatedSession = reqOrSession;
            if (!updatedSession) {
                throw new Error("The session data is missing.");
            }
            await this.sessionStore.set(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cookies"])(), await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cookies"])(), {
                ...updatedSession,
                internal: {
                    ...existingSession.internal
                }
            });
        } else {
            const req = reqOrSession;
            if (!sessionData) {
                throw new Error("The session data is missing.");
            }
            if (req instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextRequest"] && res instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"]) {
                // middleware usage
                const existingSession = await this.getSession(req);
                if (!existingSession) {
                    throw new Error("The user is not authenticated.");
                }
                await this.sessionStore.set(req.cookies, res.cookies, {
                    ...sessionData,
                    internal: {
                        ...existingSession.internal
                    }
                });
            } else {
                // pages router usage
                const existingSession = await this.getSession(req);
                if (!existingSession) {
                    throw new Error("The user is not authenticated.");
                }
                const resHeaders = new Headers();
                const resCookies = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$edge$2d$runtime$2f$cookies$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ResponseCookies"](resHeaders);
                const updatedSession = sessionData;
                const reqCookies = this.createRequestCookies(req);
                const pagesRouterRes = res;
                await this.sessionStore.set(reqCookies, resCookies, {
                    ...updatedSession,
                    internal: {
                        ...existingSession.internal
                    }
                });
                for (const [key, value] of resHeaders.entries()){
                    pagesRouterRes.setHeader(key, value);
                }
            }
        }
    }
    createRequestCookies(req) {
        const headers = new Headers();
        for(const key in req.headers){
            if (Array.isArray(req.headers[key])) {
                for (const value of req.headers[key]){
                    headers.append(key, value);
                }
            } else {
                headers.append(key, req.headers[key] ?? "");
            }
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$edge$2d$runtime$2f$cookies$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RequestCookies"](headers);
    }
    async startInteractiveLogin(options) {
        return this.authClient.startInteractiveLogin(options);
    }
    async saveToSession(data, req, res) {
        if (req && res) {
            if (req instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextRequest"] && res instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextResponse"]) {
                // middleware usage
                await this.sessionStore.set(req.cookies, res.cookies, data);
            } else {
                // pages router usage
                const resHeaders = new Headers();
                const resCookies = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$edge$2d$runtime$2f$cookies$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ResponseCookies"](resHeaders);
                const pagesRouterRes = res;
                await this.sessionStore.set(this.createRequestCookies(req), resCookies, data);
                for (const [key, value] of resHeaders.entries()){
                    pagesRouterRes.setHeader(key, value);
                }
            }
        } else {
            // app router usage: Server Components, Server Actions, Route Handlers
            try {
                await this.sessionStore.set(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cookies"])(), await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cookies"])(), data);
            } catch (e) {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.warn("Failed to persist the updated token set. `getAccessToken()` was likely called from a Server Component which cannot set cookies.");
                }
            }
        }
    }
    /**
     * Validates and extracts required configuration options.
     * @param options The client options
     * @returns The validated required options
     * @throws ConfigurationError if any required option is missing
     */ validateAndExtractRequiredOptions(options) {
        // Base required options that are always needed
        const requiredOptions = {
            domain: options.domain ?? process.env.AUTH0_DOMAIN,
            clientId: options.clientId ?? process.env.AUTH0_CLIENT_ID,
            appBaseUrl: options.appBaseUrl ?? process.env.APP_BASE_URL,
            secret: options.secret ?? process.env.AUTH0_SECRET
        };
        // Check client authentication options - either clientSecret OR clientAssertionSigningKey must be provided
        const clientSecret = options.clientSecret ?? process.env.AUTH0_CLIENT_SECRET;
        const clientAssertionSigningKey = options.clientAssertionSigningKey ?? process.env.AUTH0_CLIENT_ASSERTION_SIGNING_KEY;
        const hasClientAuthentication = !!(clientSecret || clientAssertionSigningKey);
        const missing = Object.entries(requiredOptions).filter(([, value])=>!value).map(([key])=>key);
        // Add client authentication error if neither option is provided
        if (!hasClientAuthentication) {
            missing.push("clientAuthentication");
        }
        if (missing.length) {
            // Map of option keys to their exact environment variable names
            const envVarNames = {
                domain: "AUTH0_DOMAIN",
                clientId: "AUTH0_CLIENT_ID",
                appBaseUrl: "APP_BASE_URL",
                secret: "AUTH0_SECRET"
            };
            // Standard intro message explaining the issue
            let errorMessage = "WARNING: Not all required options where provided when creating an instance of Auth0Client. Ensure to provide all missing options, either by passing it to the Auth0Client constructor, or by setting the corresponding environment variable.\n";
            // Add specific details for each missing option
            missing.forEach((key)=>{
                if (key === "clientAuthentication") {
                    errorMessage += `Missing: clientAuthentication: Set either AUTH0_CLIENT_SECRET env var or AUTH0_CLIENT_ASSERTION_SIGNING_KEY env var, or pass clientSecret or clientAssertionSigningKey in options\n`;
                } else if (envVarNames[key]) {
                    errorMessage += `Missing: ${key}: Set ${envVarNames[key]} env var or pass ${key} in options\n`;
                } else {
                    errorMessage += `Missing: ${key}\n`;
                }
            });
            console.error(errorMessage.trim());
        }
        // Prepare the result object with all validated options
        const result = {
            ...requiredOptions,
            clientSecret,
            clientAssertionSigningKey
        };
        // Type-safe assignment after validation
        return result;
    }
}
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/server/index.js [app-rsc] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$client$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/client.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$auth$2d$client$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/auth-client.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$transaction$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/transaction-store.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$abstract$2d$session$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/session/abstract-session-store.js [app-rsc] (ecmascript)");
;
;
;
;
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/server/index.js [app-rsc] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$client$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/client.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$auth$2d$client$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/auth-client.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$transaction$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/transaction-store.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$session$2f$abstract$2d$session$2d$store$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/session/abstract-session-store.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth0$2f$nextjs$2d$auth0$2f$dist$2f$server$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@auth0/nextjs-auth0/dist/server/index.js [app-rsc] (ecmascript) <locals>");
}}),

};

//# sourceMappingURL=node_modules_%40auth0_nextjs-auth0_9f0797b6._.js.map